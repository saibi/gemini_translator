# Gemini CLI 팁 및 요령

**이 가이드는 에이전트 기반 코딩을 위해 Gemini CLI를 효과적으로 사용하는 약 30가지의 프로 팁을 다룹니다.**

**[Gemini CLI](https://github.com/google-gemini/gemini-cli)**는 구글의 Gemini 모델의 강력한 기능을 여러분의 [터미널](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=The%20Gemini%20CLI%20is%20an,via%20a%20Gemini%20API%20key)로 직접 가져오는 오픈 소스 AI 어시스턴트입니다. 이 도구는 대화형 "에이전트형" 명령줄 도구로 작동합니다. 즉, 사용자의 요청을 추론하고, 도구(셸 명령 실행 또는 파일 편집 등)를 선택하며, 개발 [워크플로우](https://cloud.google.com/blog/topics/developers-practitioners/agent-factory-recap-deep-dive-into-gemini-cli-with-taylor-mullen#:~:text=The%20Gemini%20CLI%20%20is,understanding%20of%20the%20developer%20workflow)를 돕기 위해 다단계 계획을 실행할 수 있습니다.

실질적인 관점에서 Gemini CLI는 강화된 페어 프로그래머이자 명령줄 어시스턴트처럼 작동합니다. 자연어 프롬프트를 통해 코딩 작업, 디버깅, 콘텐츠 생성 및 시스템 자동화에 탁월한 성능을 발휘합니다. 프로 팁을 살펴보기 전에 Gemini CLI를 설정하고 실행하는 방법을 빠르게 복습해 보겠습니다.

## 목차

- [시작하기](#시작하기)
- [팁 1: 지속적인 컨텍스트를 위해 `GEMINI.md` 사용하기](#팁-1-지속적인-컨텍스트를-위해-geminimd-사용하기)
- [팁 2: 커스텀 슬래시 명령어 생성하기](#팁-2-커스텀-슬래시-명령어-생성하기)
- [팁 3: 자신만의 `MCP` 서버로 Gemini 확장하기](#팁-3-자신만의-mcp-서버로-gemini-확장하기)
- [팁 4: 메모리 추가 및 회상 활용하기](#팁-4-메모리-추가-및-회상-활용하기)
- [팁 5: 체크포인팅과 `/restore`를 실행 취소 버튼으로 사용하기](#팁-5-체크포인팅과-restore를-실행-취소-버튼으로-사용하기)
- [팁 6: Google Docs, Sheets 등을 읽기](#팁-6-google-docs-sheets-등을-읽기)
- [팁 7: 명시적 컨텍스트를 위해 `@`로 파일 및 이미지 참조하기](#팁-7-명시적-컨텍스트를-위해--로-파일-및-이미지-참조하기)
- [팁 8: 즉석 도구 생성 (Gemini가 도우미를 빌드하게 하기)](#팁-8-즉석-도구-생성-gemini가-도우미를-빌드하게-하기)
- [팁 9: 시스템 문제 해결 및 구성을 위해 Gemini CLI 사용하기](#팁-9-시스템-문제-해결-및-구성을-위해-gemini-cli-사용하기)
- [팁 10: YOLO 모드 - 도구 작업 자동 승인 (주의해서 사용)](#팁-10-yolo-모드---도구-작업-자동-승인-주의해서-사용)
- [팁 11: 헤드리스 및 스크립팅 모드 (백그라운드에서 Gemini CLI 실행)](#팁-11-헤드리스-및-스크립팅-모드-백그라운드에서-gemini-cli-실행)
- [팁 12: 채팅 세션 저장 및 재개](#팁-12-채팅-세션-저장-및-재개)
- [팁 13: 멀티 디렉토리 작업 공간 - 하나의 Gemini, 여러 폴더](#팁-13-멀티-디렉토리-작업-공간---하나의-gemini-여러-폴더)
- [팁 14: AI 지원을 통한 파일 정리 및 정돈](#팁-14-ai-지원을-통한-파일-정리-및-정돈)
- [팁 15: 컨텍스트 내 유지를 위해 긴 대화 압축하기](#팁-15-컨텍스트-내-유지를-위해-긴-대화-압축하기)
- [팁 16: `!`를 사용한 셸 명령 패스스루 (터미널과 대화하기)](#팁-16-를-사용한-셸-명령-패스스루-터미널과-대화하기)
- [팁 17: 모든 CLI 도구를 잠재적인 Gemini 도구로 취급하기](#팁-17-모든-cli-도구를-잠재적인-gemini-도구로-취급하기)
- [팁 18: 멀티모달 AI 활용 - Gemini가 이미지 등을 보게 하기](#팁-18-멀티모달-ai-활용---gemini가-이미지-등을-보게-하기)
- [팁 19: 안정성을 위해 `$PATH` (및 도구 가용성) 사용자 정의하기](#팁-19-안정성을-위해-path-및-도구-가용성-사용자-정의하기)
- [팁 20: 토큰 캐싱 및 통계를 통한 토큰 지출 추적 및 감소](#팁-20-토큰-캐싱-및-통계를-통한-토큰-지출-추적-및-감소)
- [팁 21: 빠른 클립보드 복사를 위해 `/copy` 사용하기](#팁-21-빠른-클립보드-복사를-위해-copy-사용하기)
- [팁 22: 셸 모드 및 종료를 위한 `Ctrl+C` 마스터하기](#팁-22-셸-모드-및-종료를-위한-ctrlc-마스터하기)
- [팁 23: `settings.json`으로 Gemini CLI 사용자 정의하기](#팁-23-settingsjson으로-gemini-cli-사용자-정의하기)
- [팁 24: 컨텍스트 및 Diff를 위해 IDE 통합(VS Code) 활용하기](#팁-24-컨텍스트-및-diff를-위해-ide-통합vs-code-활용하기)
- [팁 25: `Gemini CLI GitHub Action`으로 리포지토리 작업 자동화하기](#팁-25-gemini-cli-github-action으로-리포지토리-작업-자동화하기)
- [팁 26: 통찰력 및 관찰 가능성을 위해 텔레메트리 활성화하기](#팁-26-통찰력-및-관찰-가능성을-위해-텔레메트리-활성화하기)
- [팁 27: 로드맵 주시하기 (백그라운드 에이전트 등)](#팁-27-로드맵-주시하기-백그라운드-에이전트-등)
- [팁 28: `Extensions`로 Gemini CLI 확장하기](#팁-28-extensions로-gemini-cli-확장하기)
- [팁 29: 코기 모드 이스터 에그 🐕](#추가-재미-코기-모드-이스터-에그-)

## 시작하기

**설치:** npm을 통해 Gemini CLI를 설치할 수 있습니다. 전역 설치를 위해 다음을 사용하세요:

```bash
npm install -g @google/gemini-cli
```

또는 설치하지 않고 `npx`를 사용하여 실행하세요:

```bash
npx @google/gemini-cli
```

Gemini CLI는 모든 주요 플랫폼에서 사용할 수 있습니다(Node.js/TypeScript로 빌드됨). 설치가 완료되면 터미널에서 `gemini` 명령을 실행하여 대화형 [CLI](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=Interactive%20Mode%20,conversational%20session)를 시작하세요.

**인증:** 처음 사용할 때 Gemini 서비스로 인증해야 합니다. 두 가지 옵션이 있습니다: (1) **Google 계정 로그인 (무료 등급)** - 넉넉한 사용량 제한(분당 약 60개 요청, 하루 1,000개 요청)과 함께 Gemini 2.5 Pro를 무료로 사용할 수 있습니다. 실행 시 Gemini CLI는 Google 계정으로 로그인하도록 안내합니다(결제 불필요). (2) **API 키 (유료 또는 상위 등급 액세스)** - Google AI [Studio](https://www.philschmid.de/gemini-cli-cheatsheet#:~:text=1,key%20from%20Google%20AI%20Studio)에서 API 키를 받아 환경 변수 `GEMINI_API_KEY`에 설정하여 사용할 수 있습니다.

API 키 사용은 더 높은 할당량과 기업용 데이터 사용 보호 기능을 제공할 수 있습니다. 유료/청구 사용 시 프롬프트는 학습에 사용되지 않지만, 안전을 위해 로그가 보관될 수 있습니다.

예를 들어, 셸 프로필에 다음을 추가하세요:

```bash
export GEMINI_API_KEY="YOUR_KEY_HERE"
```

**기본 사용법:** 대화형 세션을 시작하려면 인수 없이 `gemini`를 실행하기만 하면 됩니다. 요청이나 명령을 입력할 수 있는 `gemini>` 프롬프트가 나타납니다. 예를 들어:

```bash
$ gemini
gemini> Create a React recipe management app using SQLite
```

그러면 Gemini CLI가 요청을 이행하기 위해 파일을 생성하고, 의존성을 설치하고, 테스트를 실행하는 등의 과정을 지켜볼 수 있습니다. 일회성 호출(비대화형)을 선호한다면 프롬프트와 함께 `-p` 플래그를 사용하세요. 예를 들어:

```bash
gemini -p "Summarize the main points of the attached file. @./report.txt"
```

이렇게 하면 단일 응답을 출력하고 종료됩니다. Gemini CLI로 입력을 파이프할 수도 있습니다: 예를 들어, `echo "Count to 10" | gemini`는 표준 입력을 통해 프롬프트를 전달합니다.

**CLI 인터페이스:** Gemini CLI는 풍부한 REPL 유사 인터페이스를 제공합니다. **슬래시 명령어**(세션, 도구 및 설정을 제어하기 위해 `/`로 시작하는 특수 명령)와 **뱅 명령어**(`!`로 시작하여 셸 명령을 직접 실행)를 지원합니다. 아래 프로 팁에서 이 중 많은 부분을 다룰 것입니다. 기본적으로 Gemini CLI는 시스템을 수정하는 모든 작업(파일 쓰기, 셸 명령 실행 등)에 대해 확인을 요청하는 안전 모드로 작동합니다. 도구 작업이 제안되면 diff 또는 명령이 표시되고 승인 또는 거부 여부를 묻는 메시지(`Y/n`)가 나타납니다. 이를 통해 AI가 사용자 동의 없이 원치 않는 변경을 하지 않도록 보장합니다.

기본 사항을 마쳤으므로, 이제 Gemini CLI를 최대한 활용하는 데 도움이 되는 일련의 프로 팁과 숨겨진 기능을 살펴보겠습니다. 각 팁은 먼저 간단한 예를 제시하고, 그 다음 더 깊은 세부 사항과 뉘앙스를 설명합니다. 이 팁들은 도구 제작자(예: Taylor Mullen)와 Google 개발자 관계 팀의 조언과 통찰력, 그리고 더 넓은 커뮤니티의 의견을 통합하여 Gemini CLI 파워 유저를 위한 **표준 가이드** 역할을 합니다.

## 팁 1: 지속적인 컨텍스트를 위해 `GEMINI.md` 사용하기

**빠른 사용 사례:** 프롬프트에서 같은 내용을 반복하지 마세요. `GEMINI.md` 파일을 생성하여 프로젝트 전용 컨텍스트나 지침을 제공하면, AI가 매번 지시받지 않고도 항상 중요한 배경 지식을 갖게 됩니다.

프로젝트를 작업할 때 코딩 스타일 가이드라인, 프로젝트 아키텍처 또는 중요한 사실과 같이 AI가 염두에 두었으면 하는 전반적인 세부 사항이 있는 경우가 많습니다. Gemini CLI를 사용하면 이러한 내용을 하나 이상의 `GEMINI.md` 파일로 인코딩할 수 있습니다. 프로젝트에 `.gemini` 폴더(아직 없는 경우)를 만들고, AI가 유지하기를 원하는 메모나 지침이 담긴 `GEMINI.md`라는 이름의 Markdown 파일을 추가하면 됩니다. 예를 들어:

```markdown
# Project Phoenix - AI 어시스턴트

- 모든 Python 코드는 PEP 8 스타일을 따라야 함.
- 들여쓰기에는 공백 4개를 사용함.
- 사용자는 데이터 파이프라인을 구축 중이므로 함수형 프로그래밍 패러다임을 선호함.
```

이 파일을 프로젝트 루트(또는 더 세분화된 컨텍스트를 위해 하위 디렉토리)에 배치하세요. 이제 해당 프로젝트에서 `gemini`를 실행할 때마다 이러한 지침이 컨텍스트로 자동으로 로드됩니다. 즉, 모델은 항상 이러한 지침을 바탕으로 답변할 준비가 되어 있어, 모든 프롬프트 앞에 동일한 안내를 붙일 필요가 없습니다.

**작동 방식:** Gemini CLI는 계층적 컨텍스트 로딩 시스템을 사용합니다. **전역 컨텍스트**(`~/.gemini/GEMINI.md`, 프로젝트 전반의 기본값으로 사용 가능)와 **프로젝트 전용 `GEMINI.md`**, 그리고 하위 폴더의 컨텍스트 파일을 결합합니다. 더 구체적인 파일이 더 일반적인 파일보다 우선순위를 갖습니다. 다음 명령을 사용하여 언제든지 어떤 컨텍스트가 로드되었는지 확인할 수 있습니다:

```bash
/memory show
```

이렇게 하면 AI가 보는 결합된 전체 컨텍스트가 표시됩니다. `GEMINI.md`를 변경한 경우, 세션을 다시 시작하지 않고 컨텍스트를 다시 로드하려면 `/memory refresh`를 사용하세요.

**프로 팁:** `/init` 슬래시 명령어를 사용하여 시작용 `GEMINI.md`를 빠르게 생성하세요. 새 프로젝트에서 `/init`을 실행하면 감지된 기술 스택, 프로젝트 요약 등의 정보가 포함된 템플릿 컨텍스트 파일이 생성됩니다. 그런 다음 해당 파일을 편집하고 확장할 수 있습니다. 대규모 프로젝트의 경우 컨텍스트를 여러 파일로 나누고 `@include` 구문을 사용하여 `GEMINI.md`로 **가져오는** 것을 고려해 보세요. 예를 들어 메인 `GEMINI.md`에 `@./docs/prompt-guidelines.md`와 같은 라인을 추가하여 추가 컨텍스트 파일을 불러올 수 있습니다. 이렇게 하면 지침을 체계적으로 관리할 수 있습니다.

잘 작성된 `GEMINI.md`를 통해 Gemini CLI에 프로젝트의 요구 사항과 관례에 대한 "메모리"를 효과적으로 부여할 수 있습니다. 이러한 **지속적인 컨텍스트**는 더 관련성 높은 응답으로 이어지고 불필요한 프롬프트 엔지니어링을 줄여줍니다.

## 팁 2: 커스텀 슬래시 명령어 생성하기

**빠른 사용 사례:** 자신만의 슬래시 명령어를 정의하여 반복적인 작업의 속도를 높이세요. 예를 들어, 설명으로부터 유닛 테스트를 생성하는 `/test:gen` 명령어나, 테스트 데이터베이스를 삭제하고 다시 생성하는 `/db:reset` 명령어를 만들 수 있습니다. 이를 통해 워크플로우에 맞춤화된 한 줄 명령어로 Gemini CLI의 기능을 확장할 수 있습니다.

Gemini CLI는 간단한 구성 파일에 정의할 수 있는 **커스텀 슬래시 명령어**를 지원합니다. 내부적으로 이것들은 기본적으로 미리 정의된 프롬프트 템플릿입니다. 명령어를 만들려면 전역 명령어의 경우 `~/.gemini/` 아래에, 프로젝트 전용 명령어의 경우 프로젝트의 `.gemini/` 폴더 아래에 `commands/` 디렉토리를 만드세요. `commands/` 안에 각 새 명령어에 대해 TOML 파일을 생성합니다. 파일 이름 형식이 명령어 이름을 결정합니다. 예를 들어 `test/gen.toml` 파일은 `/test:gen` 명령어를 정의합니다.

예를 들어 보겠습니다. 요구 사항 설명으로부터 유닛 테스트를 생성하는 명령어를 원한다고 가정해 봅시다. 다음과 같은 내용으로 `~/.gemini/commands/test/gen.toml`을 생성할 수 있습니다:

```markdown
# 호출 방법: /test:gen "테스트에 대한 설명"
description = "요구 사항을 기반으로 유닛 테스트를 생성합니다."
prompt = """
당신은 전문 테스트 엔지니어입니다. 다음 요구 사항을 바탕으로 Jest 프레임워크를 사용하여 포괄적인 유닛 테스트를 작성해 주세요.

요구 사항: {{args}}
"""
```

이제 Gemini CLI를 다시 로드하거나 다시 시작한 후 다음과 같이 입력할 수 있습니다:

```bash
/test:gen "로그인 버튼이 성공 시 대시보드로 리디렉션되는지 확인"
```

Gemini CLI는 `/test:gen`을 인식하고 프롬프트 템플릿의 `{{args}}`를 제공된 인수(이 경우 요구 사항)로 대체합니다. 그런 다음 AI는 그에 따라 Jest 유닛 테스트 생성을 진행합니다. `description` 필드는 선택 사항이지만 `/help` 또는 `/tools`를 실행하여 사용 가능한 명령어를 나열할 때 사용됩니다.

이 메커니즘은 매우 강력합니다. 사실상 자연어로 AI를 스크립팅할 수 있습니다. 커뮤니티에서는 수많은 유용한 커스텀 명령어를 만들었습니다. 예를 들어 Google의 개발자 관계 팀은 API 문서 작성, 데이터 정리 또는 보일러플레이트 코드 설정과 같은 일반적인 흐름을 스크립팅하는 방법을 보여주는 10가지 실용적인 워크플로우 명령어 세트를 공유했습니다. 커스텀 명령어를 정의함으로써 복잡한 프롬프트(또는 일련의 프롬프트)를 재사용 가능한 바로가기로 패키징할 수 있습니다.

**프로 팁:** 커스텀 명령어는 특정 작업에 대해 서식을 강제하거나 AI에 "페르소나"를 적용하는 데에도 사용할 수 있습니다. 예를 들어, 코드의 취약점을 검토하기 위해 항상 프롬프트 앞에 "당신은 보안 감사관입니다..."라는 문구를 붙이는 `/review:security` 명령어를 가질 수 있습니다. 이러한 방식은 AI가 특정 범주의 작업에 응답하는 방식의 일관성을 보장합니다.

팀과 명령어를 공유하려면 프로젝트 리포지토리에 TOML 파일을 커밋하면 됩니다(`.gemini/commands` 디렉토리 아래). Gemini CLI를 사용하는 팀원들은 해당 프로젝트에서 작업할 때 이러한 명령어들을 자동으로 사용할 수 있게 됩니다. 이는 팀 전체에서 **AI 지원 워크플로우를 표준화**하는 좋은 방법입니다.

## 팁 3: 자신만의 `MCP` 서버로 Gemini 확장하기

**빠른 사용 사례:** Gemini가 내장되지 않은 외부 시스템이나 커스텀 도구(예: 독점 데이터베이스 쿼리 또는 Figma 디자인 통합)와 인터페이스하기를 원한다고 가정해 봅시다. 커스텀 **Model Context Protocol (MCP) 서버**를 실행하고 이를 Gemini CLI에 연결하여 이를 수행할 수 있습니다. MCP 서버를 사용하면 Gemini에 새로운 도구와 능력을 추가하여 효과적으로 **에이전트를 확장**할 수 있습니다.

Gemini CLI에는 기본적으로 몇 가지 MCP 서버가 포함되어 있으며(예: Google 검색, 코드 실행 샌드박스 등 활성화), 직접 추가할 수도 있습니다. MCP 서버는 기본적으로 Gemini의 작업을 처리하기 위해 간단한 프로토콜을 사용하는 외부 프로세스(로컬 스크립트, 마이크로서비스 또는 클라우드 엔드포인트일 수 있음)입니다. 이 아키텍처가 Gemini CLI를 매우 확장 가능하게 만듭니다.

**MCP 서버 예시:** 일부 커뮤니티 및 Google 제공 MCP 통합에는 Figma에서 디자인 세부 정보를 가져오는 **Figma MCP**, 시스템 클립보드에서 읽기/쓰기를 하는 **Clipboard MCP** 등이 포함됩니다. 실제로 내부 데모에서 Gemini CLI 팀은 콘텐츠를 Google Docs에 직접 저장할 수 있는 "Google Docs MCP" 서버를 선보였습니다. 핵심 아이디어는 Gemini가 내장 도구로 처리할 수 없는 작업을 수행해야 할 때마다 여러분의 MCP 서버에 위임할 수 있다는 것입니다.

**추가 방법:** `settings.json`을 통하거나 CLI를 사용하여 MCP 서버를 구성할 수 있습니다. 빠른 설정을 위해 다음 CLI 명령어를 시도해 보세요:

```bash
gemini mcp add myserver --command "python3 my_mcp_server.py" --port 8080
```

이렇게 하면 포트 8080에서 지정된 명령(여기서는 Python 모듈)을 실행하여 Gemini CLI가 실행할 "myserver"라는 이름의 서버가 등록됩니다. `~/.gemini/settings.json`에서는 `mcpServers` 아래에 항목이 추가됩니다. 예를 들어:

```json
"mcpServers": {
  "myserver": {
    "command": "python3",
    "args": ["-m", "my_mcp_server", "--port", "8080"],
    "cwd": "./mcp_tools/python",
    "timeout": 15000
  }
}
```

이 구성은 Gemini에 MCP 서버를 시작하는 방법과 위치를 알려줍니다. 서버가 실행되면 해당 서버에서 제공하는 도구들을 Gemini CLI에서 사용할 수 있게 됩니다. 슬래시 명령어를 사용하여 모든 MCP 서버와 도구를 나열할 수 있습니다:

```bash
/mcp
```

이렇게 하면 등록된 서버와 해당 서버가 노출하는 도구 이름이 표시됩니다.

**MCP의 위력:** MCP 서버는 **풍부한 멀티모달 결과**를 제공할 수 있습니다. 예를 들어 MCP를 통해 제공되는 도구는 Gemini CLI의 응답의 일부로 이미지나 형식이 지정된 표를 반환할 수 있습니다. 또한 OAuth 2.0을 지원하므로 자격 증명을 노출하지 않고도 MCP 도구를 통해 API(Google API, GitHub 등)에 안전하게 연결할 수 있습니다. 기본적으로 코딩할 수 있다면 무엇이든 MCP 도구로 래핑할 수 있으며, Gemini CLI를 여러 서비스를 오케스트레이션하는 허브로 만들 수 있습니다.

**기본 vs. 커스텀:** 기본적으로 Gemini CLI의 내장 도구는 파일 읽기, 웹 검색, 셸 명령 실행 등 많은 부분을 다루지만, MCP를 통해 그 이상으로 나아갈 수 있습니다. 일부 고급 사용자들은 내부 시스템과 인터페이스하거나 특수한 데이터 처리를 수행하기 위해 MCP 서버를 만들었습니다. 예를 들어 회사 데이터베이스에서 SQL 쿼리를 실행하기 위한 `/query_db` 도구를 제공하는 `database-mcp`나, 자연어로 티켓을 생성하는 `jira-mcp`를 가질 수 있습니다.

직접 만들 때는 보안에 유의하세요. 기본적으로 커스텀 MCP 도구는 신뢰할 수 있는 것으로 표시하지 않는 한 확인이 필요합니다. 서버에 대해 `trust: true`와 같은 설정을 사용하거나(도구 작업을 자동 승인함), 특정 안전한 도구는 허용하고 위험한 도구는 차단하는 방식으로 안전을 제어할 수 있습니다.

요약하자면, **MCP 서버는 무한한 통합의 가능성을 열어줍니다.** 이는 Gemini CLI를 AI 어시스턴트와 작업에 필요한 모든 시스템 사이의 접착제로 만들어주는 프로 기능입니다. 직접 구축해보고 싶다면 공식 MCP 가이드와 커뮤니티 예시를 확인해 보세요.

## 팁 4: 메모리 추가 및 회상 활용하기

**빠른 사용 사례:** 중요한 사실들을 AI의 장기 메모리에 추가하여 언제든지 사용할 수 있게 하세요. 예를 들어, 데이터베이스 포트나 API 토큰을 파악한 후 다음과 같이 할 수 있습니다:

```bash
/memory add "우리의 스테이징 RabbitMQ는 5673 포트에 있음"
```

이렇게 하면 해당 사실이 저장되어 나중에 사용자나 AI가 잊어버리지 않게 됩니다. 언제든지 `/memory show`를 사용하여 메모리의 모든 내용을 다시 확인할 수 있습니다.

`/memory` 명령어는 *지속적인 메모리*를 위한 단순하지만 강력한 메커니즘을 제공합니다. `/memory add <text>`를 사용하면 지정된 텍스트가 프로젝트의 전역 컨텍스트에 추가됩니다(기술적으로는 전역 `~/.gemini/GEMINI.md` 파일이나 프로젝트의 `GEMINI.md`에 저장됨). 이는 마치 노트를 작성하여 AI의 가상 게시판에 핀으로 고정하는 것과 같습니다. 일단 추가되면, AI는 세션을 가리지 않고 향후 상호작용을 위한 프롬프트 컨텍스트에서 해당 노트를 항상 보게 됩니다.

예를 들어 보겠습니다. 문제를 디버깅하다가 명확하지 않은 통찰("설정 플래그 `X_ENABLE`이 `true`로 설정되어야 서비스가 시작됨")을 발견했다고 합시다. 이를 메모리에 추가하면, 나중에 사용자나 AI가 관련 문제를 논의할 때 이 중요한 세부 사항을 간과하지 않게 됩니다. 컨텍스트에 포함되어 있기 때문입니다.

**`/memory` 사용법:**

* `/memory add "<text>"` - 메모리에 사실이나 노트를 추가합니다(지속적인 컨텍스트). 이는 즉시 `GEMINI.md`를 새 항목으로 업데이트합니다.
* `/memory show` - 메모리의 전체 내용(즉, 현재 로드된 결합된 컨텍스트 파일)을 표시합니다.
* `/memory refresh` - 디스크에서 컨텍스트를 다시 로드합니다(Gemini CLI 외부에서 `GEMINI.md` 파일을 수동으로 편집했거나 여러 사람이 협업하는 경우 유용함).

메모리는 Markdown 형식으로 저장되므로, `GEMINI.md` 파일을 수동으로 편집하여 정보를 선별하거나 정리할 수도 있습니다. `/memory` 명령어는 대화 중에 에디터를 열 필요 없이 편리하게 사용하기 위한 것입니다.

**프로 팁:** 이 기능은 "의사 결정 로그"에 적합합니다. 채팅 중에 결정된 방식이나 규칙(예: 사용할 특정 라이브러리 또는 합의된 코드 스타일)이 있다면 메모리에 추가하세요. 그러면 AI는 해당 결정을 기억하고 나중에 그와 모순되는 제안을 하지 않게 됩니다. 특히 몇 시간 또는 며칠에 걸친 긴 세션에서 유용합니다. 주요 지점을 저장함으로써 대화가 길어질 때 모델이 이전 컨텍스트를 잊어버리는 경향을 완화할 수 있습니다.

또 다른 용도는 개인적인 메모입니다. `~/.gemini/GEMINI.md`(전역 메모리)는 모든 세션에 로드되므로 일반적인 선호도나 정보를 그곳에 둘 수 있습니다. 예를 들어 "사용자의 이름은 Alice입니다. 정중하게 말하고 속어는 피하세요."와 같은 내용입니다. 이는 AI의 페르소나나 전역 지식을 구성하는 것과 같습니다. 다만 전역 메모리는 *모든* 프로젝트에 적용되므로 프로젝트 전용 정보로 어지럽히지 않도록 주의하세요.

요약하자면, **메모리 추가 및 회상**은 Gemini CLI가 상태를 유지하도록 돕습니다. 프로젝트와 함께 성장하는 지식 베이스라고 생각하세요. 같은 말을 반복하지 않거나 AI가 처음부터 다시 발견해야 할 사실들을 상기시키는 데 사용하세요.

## 팁 5: 체크포인팅과 `/restore`를 실행 취소 버튼으로 사용하기

**빠른 사용 사례:** Gemini CLI가 파일에 가한 일련의 변경 사항이 마음에 들지 않는 경우, 즉시 이전 상태로 **되돌릴** 수 있습니다. Gemini를 시작할 때(또는 설정에서) 체크포인팅을 활성화하고, 가벼운 Git 되돌리기처럼 `/restore` 명령어를 사용하여 변경 사항을 취소하세요. `/restore`는 작업 공간을 저장된 체크포인트로 되돌립니다. 체크포인트가 캡처된 방식에 따라 대화 상태도 영향을 받을 수 있습니다.

Gemini CLI의 **체크포인팅** 기능은 안전망 역할을 합니다. 활성화되면 CLI는 파일을 수정하는 각 도구 실행 *직전*에 프로젝트 파일의 스냅샷을 찍습니다. 문제가 발생하면 마지막으로 확인된 정상 상태로 복구할 수 있습니다. 매번 수동으로 Git에 커밋할 필요 없이 AI의 작업에 대한 버전 관리를 하는 것과 같습니다.

**사용 방법:** `--checkpointing` 플래그를 사용하여 CLI를 실행하면 체크포인팅을 켤 수 있습니다:

```bash
gemini --checkpointing
```

또는 `settings.json`에서 `"checkpointing": { "enabled": true }`를 추가하여 기본값으로 설정할 수 있습니다. 활성화되면 Gemini가 파일을 쓰려고 할 때마다 "Checkpoint saved"와 같은 메시지가 표시되는 것을 볼 수 있습니다.

나중에 AI가 수행한 편집에 문제가 있음을 깨닫는다면 두 가지 옵션이 있습니다:

* `/restore list`(또는 인자 없이 `/restore`)를 실행하여 타임스탬프와 설명이 포함된 최근 체크포인트 목록을 확인합니다.
* `/restore <id>`를 실행하여 특정 체크포인트로 롤백합니다. ID를 생략하고 대기 중인 체크포인트가 하나뿐인 경우 기본적으로 해당 체크포인트가 복구됩니다.

예를 들어:

```bash
/restore
```

Gemini CLI는 다음과 같이 출력할 수 있습니다:

0: [2025-09-22 10:30:15] 'apply_patch' 실행 전
1: [2025-09-22 10:45:02] 'write_file' 실행 전

그런 다음 `/restore 0`을 수행하여 모든 파일 변경 사항(심지어 대화 컨텍스트까지)을 해당 체크포인트 시점으로 되돌릴 수 있습니다. 이런 방식으로 잘못된 코드 리팩토링이나 Gemini가 수행한 다른 변경 사항들을 "취소"할 수 있습니다.

**복구되는 내용:** 체크포인트는 작업 디렉토리의 상태(Gemini CLI가 수정할 수 있는 모든 파일)와 작업 공간 파일을 캡처합니다(체크포인트 캡처 방식에 따라 대화 메모리도 롤백될 수 있음). 복구 시 파일을 이전 버전으로 덮어쓰고 대화 메모리를 해당 스냅샷으로 재설정합니다. 마치 AI 에이전트를 잘못된 길로 들어서기 전으로 시간 여행시키는 것과 같습니다. 다만 외부적인 부작용(예: AI가 데이터베이스 마이그레이션을 실행한 경우)은 되돌릴 수 없지만, 파일 시스템과 채팅 컨텍스트에 있는 것이라면 무엇이든 가능합니다.

**베스트 프랙티스:** 사소하지 않은 작업의 경우 체크포인팅을 켜두는 것이 좋습니다. 오버헤드는 적으면서 마음의 평안을 줍니다. 체크포인트가 필요 없다고 판단되면(모든 것이 잘 진행됨) 언제든지 지우거나 다음 체크포인트가 덮어쓰도록 두면 됩니다. 개발 팀은 특히 다단계 코드 편집 전에 체크포인팅을 사용할 것을 권장합니다. 하지만 미션 크리티컬한 프로젝트의 경우 여전히 적절한 버전 관리(`git`)를 기본 안전망으로 사용해야 합니다. 체크포인트는 전체 VCS라기보다는 빠른 실행 취소를 위한 편의 기능으로 생각하세요.

본질적으로 `/restore`는 여러분이 확신을 가지고 Gemini CLI를 사용할 수 있게 해줍니다. 필요할 때 되감기할 수 있는 **"안돼!" 버튼**이 있다는 것을 알고, AI가 과감한 변경을 시도하도록 맡길 수 있습니다.

## 팁 6: Google Docs, Sheets 등을 읽기

**빠른 사용 사례:** AI가 사용했으면 하는 사양이나 데이터가 담긴 Google Doc 또는 Sheet가 있다고 상상해 보세요. 콘텐츠를 복사해서 붙여넣는 대신 링크를 제공하면, 구성된 Workspace MCP 서버를 통해 Gemini CLI가 이를 가져와 읽을 수 있습니다.

예를 들어:

```bash
이 디자인 문서의 요구 사항을 요약해 줘: https://docs.google.com/document/d/<id>
```

Gemini는 해당 문서의 내용을 가져와 응답에 반영할 수 있습니다. 마찬가지로 링크를 통해 Google Sheets나 Drive 파일을 읽을 수도 있습니다.

**작동 방식:** 이러한 기능은 일반적으로 **MCP 통합**을 통해 활성화됩니다. Google의 Gemini CLI 팀은 Google Workspace용 커넥터를 구축했습니다(또는 작업 중입니다). 한 가지 방법은 URL이나 ID가 주어졌을 때 Google API(Docs API, Sheets API 등)를 사용하여 문서 콘텐츠를 검색하는 작은 MCP 서버를 실행하는 것입니다. 구성이 완료되면 `/read_google_doc`과 같은 슬래시 명령어 또는 도구를 사용할 수 있으며, 단순히 Google Docs 링크를 감지하여 자동으로 가져오기 위한 적절한 도구를 호출할 수도 있습니다.

예를 들어, Agent Factory 팟캐스트 데모에서 팀은 요약 내용을 문서에 직접 저장하기 위해 **Google Docs MCP**를 사용했습니다. 이는 반대로 문서의 내용을 읽을 수도 있음을 의미합니다. 실제로 다음과 같이 사용할 수 있습니다:

```bash
@https://docs.google.com/document/d/XYZ12345
```

URL과 함께 `@`(컨텍스트 참조 구문)를 포함하면 Gemini CLI에 해당 리소스를 가져오도록 신호를 보냅니다. Google Docs 통합이 설정되어 있으면 해당 문서의 내용이 로컬 파일인 것처럼 불러와집니다. 거기서부터 AI는 이를 요약하거나, 질문에 답하거나, 대화에 활용할 수 있습니다.

마찬가지로 Google Drive **파일 링크**를 붙여넣으면, 적절히 구성된 Drive 도구가 해당 파일을 다운로드하거나 열 수 있습니다(권한 및 API 액세스가 설정되었다고 가정할 때). **Google Sheets**는 셀 범위를 읽거나 쿼리를 실행하는 MCP를 통해 사용할 수 있으며, "이 시트 [링크]의 예산 열 합계는 얼마야?"와 같은 질문을 하고 AI가 이를 계산하게 할 수 있습니다.

**설정 방법:** 이 글을 쓰는 시점에서 Google Workspace 통합은 약간의 조정(API 자격 증명 획득, MCP 서버 실행 등)이 필요할 수 있습니다. 공식 Gemini CLI 리포지토리와 커뮤니티 포럼에서 바로 사용할 수 있는 확장 기능(예: 공식 Google Docs MCP가 플러그인/확장 기능으로 제공될 수 있음)을 주시하세요. 직접 만들고 싶다면 MCP 서버 내에서 Google API를 사용하는 방법에 대한 가이드를 따를 수 있습니다. 일반적으로 OAuth 처리(Gemini CLI가 MCP 서버에 대해 지원함)와 `read_google_doc`과 같은 도구를 노출하는 작업이 포함됩니다.

**사용 팁:** 이러한 도구가 있으면 프롬프트에 링크를 제공하거나(AI가 자동으로 도구를 호출하여 가져올 수 있음) `/doc open <URL>`과 같은 슬래시 명령어를 사용하는 것만큼이나 간단해질 수 있습니다. `/tools`를 확인하여 어떤 명령어를 사용할 수 있는지 확인해 보세요. Gemini CLI는 사용 가능한 모든 도구와 커스텀 명령어를 그곳에 나열합니다.

요약하자면, **Gemini CLI는 로컬 파일 시스템 너머까지 도달할 수 있습니다.** Google Docs, Sheets, Drive 또는 다른 외부 콘텐츠이든 참조를 통해 데이터를 가져올 수 있습니다. 이 프로 팁은 수동 복사-붙여넣기 수고를 덜어주고 컨텍스트 흐름을 자연스럽게 유지해 줍니다. 필요한 문서나 데이터셋을 언급하기만 하면 AI가 필요한 것을 가져옵니다. 이는 Gemini CLI를 디스크에 있는 파일뿐만 아니라 여러분이 액세스할 수 있는 모든 정보에 대한 진정한 **지식 어시스턴트**로 만들어 줍니다.

*(참고: 비공개 문서에 액세스하려면 당연히 CLI에 적절한 권한이 있어야 합니다. 모든 통합이 보안 및 개인정보 보호를 준수하는지 항상 확인하세요. 기업 환경에서는 이러한 통합을 설정하는 데 추가적인 인증 단계가 포함될 수 있습니다.)*

## 팁 7: 명시적 컨텍스트를 위해 `@`로 파일 및 이미지 참조하기

**빠른 사용 사례:** 파일의 내용이나 이미지를 말로 설명하는 대신, Gemini CLI가 직접 볼 수 있게 가리키세요. `@` 구문을 사용하여 프롬프트에 파일, 디렉토리 또는 이미지를 첨부할 수 있습니다. 이는 AI가 해당 파일의 정확한 내용을 컨텍스트로 보도록 보장합니다. 예를 들어:

```bash
이 코드를 나에게 설명해 줘: @./src/main.js
```

이렇게 하면 프롬프트에 `src/main.js`의 내용이 포함되어(Gemini의 컨텍스트 크기 제한 내에서) AI가 이를 읽고 설명할 수 있습니다.

이 `@` **파일 참조**는 개발자를 위한 Gemini CLI의 가장 강력한 기능 중 하나입니다. 이는 모호함을 제거합니다. 모델이 파일에 대한 기억이나 추측에 의존하도록 요청하는 대신, 말 그대로 읽을 파일을 직접 건네주는 것입니다. 소스 코드, 텍스트 문서, 로그 등에 이를 사용할 수 있습니다. 마찬가지로 **전체 디렉토리**를 참조할 수도 있습니다:

```bash
@./utils/ 에 있는 코드를 async/await를 사용하도록 리팩토링해 줘.
```

슬래시로 끝나는 경로를 추가하면 Gemini CLI는 해당 디렉토리의 파일들을 재귀적으로 포함합니다(무시 파일 및 크기 제한을 준수하는 범위 내에서). 이는 AI가 모든 관련 모듈을 함께 고려할 수 있으므로 다중 파일 리팩토링이나 분석에 좋습니다.

더욱 인상적인 것은 프롬프트에서 **이미지와 같은 바이너리 파일**을 참조할 수 있다는 점입니다. Gemini CLI는(Gemini 모델의 멀티모달 기능을 사용하여) 이미지를 이해할 수 있습니다. 예를 들어:

```bash
이 스크린샷에서 무엇이 보이는지 설명해 줘: @./design/mockup.png
```

이미지가 모델에 입력되면 AI는 "파란색 로그인 버튼과 헤더 이미지가 있는 로그인 페이지입니다" 등과 같이 응답할 수 있습니다. UI 목업 검토, 사진 정리(나중에 팁에서 다룸) 또는 이미지에서 텍스트 추출(Gemini는 OCR도 가능함) 등 다양한 용도로 활용할 수 있습니다.

`@` 참조를 효과적으로 사용하기 위한 몇 가지 참고 사항:

* **파일 제한:** Gemini 2.5 Pro는 거대한 컨텍스트 창(최대 100만 토큰)을 가지고 있어 상당히 큰 파일이나 많은 파일을 포함할 수 있습니다. 하지만 매우 큰 파일은 잘릴 수 있습니다. 파일이 너무 방대하다면 요약하거나 부분으로 나누는 것을 고려하세요. 참조가 너무 크거나 크기 때문에 일부가 생략된 경우 Gemini CLI가 경고를 표시합니다.
* **자동 무시:** 기본적으로 Gemini CLI는 디렉토리 컨텍스트를 불러올 때 `.gitignore` 및 `.geminiignore` 파일을 준수합니다. 따라서 프로젝트 루트를 `@./`로 참조하더라도 `node_modules`와 같은 거대한 무시 폴더를 프롬프트에 쏟아붓지 않습니다. `.gitignore`와 유사한 방식으로 `.geminiignore`를 사용하여 무시 패턴을 사용자 정의할 수 있습니다.
* **명시적 컨텍스트 vs. 암시적 컨텍스트:** Gemini CLI 제작자인 Taylor Mullen은 모델의 기억이나 직접 요약한 내용에 의존하기보다 **명시적 컨텍스트 주입**을 위해 `@`를 사용할 것을 강조합니다. 이것이 더 정확하며 AI가 내용을 환각(hallucinating)하지 않도록 보장합니다. 가능할 때마다 `@` 참조를 통해 AI를 진실의 원천(소스 코드, 설정 파일, 문서)으로 안내하세요. 이 습관은 정확도를 크게 향상시킬 수 있습니다.
* **참조 체이닝:** 다음과 같이 하나의 프롬프트에 여러 파일을 포함할 수 있습니다:

```bash
@./foo.py 와 @./bar.py 를 비교해서 차이점을 알려줘.
```

CLI는 두 파일을 모두 포함합니다. 토큰 제한에 유의하세요. 큰 파일이 여러 개 있으면 컨텍스트 창의 많은 부분을 소모할 수 있습니다.

`@`를 사용하는 것은 기본적으로 **Gemini CLI에 지식을 즉석에서 공급하는 방법**입니다. 이는 CLI를 텍스트와 이미지를 모두 처리할 수 있는 멀티모달 리더로 변모시킵니다. 파워 유저로서 이를 활용하는 습관을 들이세요. AI에게 "X 파일을 열고 Y를 해줘"라고 말하는 것(AI가 스스로 할 수도 있고 안 할 수도 있음)보다 훨씬 빠르고 안정적인 경우가 많습니다. 대신, 명시적으로 작업할 X를 주는 것입니다.

## 팁 8: 즉석 도구 생성 (Gemini가 도우미를 빌드하게 하기)

**빠른 사용 사례:** 현재 작업에 작은 스크립트나 유틸리티가 도움이 된다면, 세션 내에서 바로 Gemini CLI에게 해당 도구를 만들어 달라고 요청할 수 있습니다. 예를 들어, "이 폴더의 모든 JSON 파일을 파싱하고 에러 필드를 추출하는 Python 스크립트를 작성해 줘"라고 말할 수 있습니다. Gemini는 스크립트를 생성하고, 사용자는 이를 CLI를 통해 실행할 수 있습니다. 본질적으로 진행하면서 **도구 세트를 동적으로 확장**할 수 있는 것입니다.

Gemini CLI는 기존 도구에 국한되지 않습니다. 코딩 능력을 사용하여 필요할 때 새로운 도구를 만들어낼 수 있습니다. 이는 종종 암시적으로 발생합니다. 복잡한 것을 요청하면 AI가 임시 파일(코드 포함)을 작성하고 실행할 것을 제안할 수 있습니다. 사용자로서 이 과정을 명시적으로 안내할 수도 있습니다:

* **스크립트 생성:** 원하는 언어로 스크립트나 프로그램을 만들도록 Gemini에게 요청할 수 있습니다. 아마도 `write_file` 도구를 사용하여 파일을 생성할 것입니다. 예를 들어:

```bash
현재 디렉토리의 모든 '.log' 파일을 읽고 각각의 라인 수를 보고하는 Node.js 스크립트를 생성해 줘.
```

Gemini CLI는 코드를 초안 작성하고, 사용자의 승인을 받아 파일(예: `script.js`)에 씁니다. 그런 다음 `!` 셸 명령어(예: `!node script.js`)를 사용하거나 Gemini CLI에게 실행하도록 요청하여 이를 실행할 수 있습니다(AI가 계획의 일부라고 판단하면 방금 작성한 스크립트를 실행하기 위해 `run_shell_command`를 자동으로 사용할 수도 있습니다).

* **MCP를 통한 임시 도구:** 고급 시나리오에서는 AI가 일부 특수 작업을 위해 MCP 서버를 실행하도록 제안할 수도 있습니다. 예를 들어 프롬프트에 Python에서 더 잘 처리될 수 있는 무거운 텍스트 처리가 포함된 경우, Gemini는 Python으로 간단한 MCP 서버를 생성하고 실행할 수 있습니다. 이는 드문 경우지만 AI가 즉석에서 새로운 "에이전트"를 설정할 수 있음을 보여줍니다.

여기서 핵심적인 이점은 **자동화**입니다. 도우미 스크립트를 작성하기 위해 수동으로 멈추는 대신, 흐름의 일부로 AI가 이를 수행하게 할 수 있습니다. 마치 필요할 때 도구를 만들 수 있는 어시스턴트를 둔 것과 같습니다. 이는 특히 데이터 변환 작업, 일괄 작업 또는 내장 도구가 직접 제공하지 않는 일회성 계산에 유용합니다.

**뉘앙스 및 안전:** Gemini CLI가 새 도구를 위한 코드를 작성할 때, 실행하기 전에 코드를 검토해야 합니다. `/diff` 뷰(Gemini는 쓰기 승인 전 파일 diff를 보여줌)는 코드를 검사할 기회입니다. 코드가 예상대로 작동하고 악의적이거나 파괴적인 부분이 없는지 확인하세요(사용자의 프롬프트가 명시적으로 요청하지 않는 한 AI가 해로운 것을 생성해서는 안 되지만, AI가 만든 모든 코드와 마찬가지로 로직, 특히 많은 데이터를 삭제하거나 수정하는 스크립트의 경우 다시 한 번 확인하세요).

**예시 시나리오:** CSV 파일이 있고 이를 복잡한 방식으로 필터링하고 싶다고 가정해 봅시다. Gemini CLI에게 요청하면 "CSV를 파싱하고 필터를 적용하기 위해 Python 스크립트를 작성하겠습니다"라고 말할 수 있습니다. 그런 다음 `filter_data.py`를 생성합니다. 사용자가 승인하고 실행되면 결과를 얻게 되며, 그 스크립트가 다시는 필요하지 않을 수도 있습니다. 이러한 일시적인 도구 생성은 프로의 기술입니다. AI가 자율적으로 자신의 능력을 효과적으로 확장하는 모습을 보여주기 때문입니다.

**프로 팁:** 스크립트가 즉각적인 컨텍스트를 넘어 유용하다고 판단되면 영구적인 도구나 명령어로 승격시킬 수 있습니다. 예를 들어 AI가 훌륭한 로그 처리 스크립트를 생성했다면 나중에 이를 쉬운 재사용을 위해 커스텀 슬래시 명령어(팁 2)로 바꿀 수 있습니다. Gemini의 생성 능력과 확장 후크의 결합은 CLI를 사용함에 따라 도구 상자가 계속 진화할 수 있음을 의미합니다.

요약하자면, **Gemini를 기본 제공 기능으로만 제한하지 마세요.** 문제를 해결하는 데 도움이 되는 새로운 프로그램이나 미니 서버를 즉석에서 만들어낼 수 있는 주니어 개발자로 생각하세요. 이러한 접근 방식은 Gemini CLI의 에이전트 철학을 구현한 것입니다. 제자리에 코딩해야 하더라도 어떤 도구가 필요한지 스스로 알아낼 것입니다.

## 팁 9: 시스템 문제 해결 및 구성을 위해 Gemini CLI 사용하기

**빠른 사용 사례:** 코드 프로젝트 외부에서 Gemini CLI를 실행하여 일반적인 시스템 작업을 도울 수 있습니다. OS를 위한 지능형 어시스턴트라고 생각하세요. 예를 들어 셸이 제대로 작동하지 않는 경우, 홈 디렉토리에서 Gemini를 열고 "내 `.bashrc` 파일에 오류가 있는데 고쳐줘"라고 요청할 수 있습니다. 그러면 Gemini가 사용자를 대신해 구성 파일을 열고 편집할 수 있습니다.

이 팁은 **Gemini CLI가 단지 코딩 프로젝트만을 위한 것이 아니라 전체 개발 환경을 위한 AI 도우미**라는 점을 강조합니다. 많은 사용자들이 개발 설정을 사용자 정의하거나 머신의 문제를 해결하기 위해 Gemini를 사용해 왔습니다:

* **도트파일(Dotfiles) 편집:** 셸 설정(`.bashrc` 또는 `.zshrc`)을 참조(`@~/.bashrc`)하여 로드한 다음 Gemini CLI에게 이를 최적화하거나 문제를 해결하도록 요청할 수 있습니다. 예를 들어 "내 `PATH`가 Go 바이너리를 인식하지 못하는데, 고칠 수 있도록 `.bashrc`를 편집해 줄래?"라고 하면 AI가 올바른 `export` 라인을 삽입할 수 있습니다. 변경 사항을 저장하기 전에 확인을 위한 diff를 보여줍니다.
* **오류 진단:** 터미널이나 애플리케이션 로그에서 이해하기 어려운 오류가 발생하면, 이를 복사하여 Gemini CLI에 입력하세요. 오류 메시지를 분석하고 종종 해결 단계를 제안할 것입니다. 이는 StackOverflow나 Google을 사용하는 것과 비슷하지만, AI가 직접 사용자의 시나리오를 검토한다는 점이 다릅니다. 예를 들어: "`npm install`을 실행할 때 `EACCES` 권한 오류가 발생해 - 어떻게 고쳐야 해?"라고 하면 Gemini는 `node_modules`의 권한 문제임을 감지하고 디렉토리 소유권을 변경하거나 적절한 node 버전 관리자를 사용하도록 안내할 수 있습니다.
* **프로젝트 외부에서 실행:** 기본적으로 `.gemini` 컨텍스트가 없는 디렉토리에서 `gemini`를 실행하면 프로젝트 관련 컨텍스트가 로드되지 않을 뿐, CLI는 여전히 완전히 사용할 수 있습니다. 이는 시스템 문제 해결과 같은 임시 작업에 적합합니다. 고려할 코드 파일이 없을 수도 있지만, 여전히 이를 통해 셸 명령을 실행하거나 웹 정보를 가져오게 할 수 있습니다. 본질적으로 Gemini CLI를 단순한 채팅 도구가 아니라 사용자를 위해 무언가를 *할 수 있는* AI 기반 터미널로 취급하는 것입니다.
* **워크스테이션 사용자 정의:** 설정을 변경하거나 새 도구를 설치하고 싶으신가요? Gemini CLI에게 "내 시스템에 Docker를 설치해 줘" 또는 "GPG로 커밋에 서명하도록 Git을 구성해 줘"라고 요청할 수 있습니다. CLI는 단계를 실행하려고 시도할 것입니다. 검색 도구를 사용하여 웹에서 지침을 가져온 다음 적절한 셸 명령을 실행할 수 있습니다. 물론 항상 진행 상황을 지켜보고 명령을 승인해야 하지만, 다단계 설정 프로세스를 자동화하여 시간을 절약할 수 있습니다. 한 실제 예로, 사용자가 Gemini CLI에게 "내 macOS Dock 설정을 자동으로 숨기고 지연 시간을 제거하도록 설정해 줘"라고 요청했고, AI는 필요한 `defaults write` 명령을 실행할 수 있었습니다.

이 모드는 Gemini CLI를 **스마트 셸**로 사용하는 것으로 생각하세요. 실제로 이를 팁 16(셸 패스스루 모드)과 결합할 수 있습니다. 때로는 무언가를 확인하기 위해 `!` 셸 모드로 들어갔다가, 출력을 분석하기 위해 다시 AI 모드로 돌아올 수도 있습니다.

**주의 사항:** 시스템 수준의 작업을 수행할 때는 광범위한 영향을 미치는 명령(`rm -rf`나 시스템 구성 변경 등)에 주의하세요. Gemini CLI는 보통 확인을 요청하며, 사용자가 보지 않는 한 아무것도 실행하지 않습니다. 하지만 파워 유저라면 어떤 변경이 이루어지고 있는지 파악하고 있어야 합니다. 확실하지 않다면 실행 전에 명령을 설명해 달라고 요청하세요(예: "`defaults write com.apple.dock autohide-delay -float 0`이 무엇을 하는지 설명해 줘" - 요청하면 그냥 실행하는 대신 기꺼이 설명해 줄 것입니다).

**문제 해결 보너스:** 또 다른 깔끔한 용도는 Gemini CLI를 사용하여 로그나 구성 파일에서 문제를 찾는 것입니다. 예를 들어 `@httpd.conf`와 함께 "이 Apache 설정에서 실수가 있는지 스캔해 줘"라거나, 액세스 가능하다면 `@/var/log/syslog`와 함께 "어제 오후 2시경의 오류 로그를 찾아줘"라고 할 수 있습니다. 공동 관리자를 둔 것과 같습니다. 심지어 충돌의 가능성 있는 원인을 제안하거나 일반적인 오류 패턴에 대한 수정안을 제안할 수도 있습니다.

요약하자면, **환경 문제에 대한 어시스턴트로 Gemini CLI를 가동하는 것을 주저하지 마세요.** 코드 작성뿐만 아니라 코드를 작성하는 시스템을 유지 관리하는 등 모든 워크플로우를 가속화하기 위해 그곳에 있습니다. 많은 사용자들이 Gemini의 도움으로 개발 환경을 사용자 정의하는 것이 지루하거나 복잡한 설정 단계를 처리하기 위해 항상 대기 중인 기술 친구를 둔 것 같다고 보고합니다.

## 팁 10: YOLO 모드 - 도구 작업 자동 승인 (주의해서 사용)

**빠른 사용 사례:** 자신감이 있거나(혹은 모험심이 강하다면), 매번 확인을 요청하지 않고 Gemini CLI가 도구 작업을 실행하도록 할 수 있습니다. 이것이 **YOLO 모드**(You Only Live Once)입니다. `--yolo` 플래그를 사용하거나 세션 중에 `Ctrl+Y`를 눌러 활성화할 수 있습니다. YOLO 모드에서는 AI가 도구(셸 명령 실행 또는 파일 쓰기 등)를 결정하는 즉시 "Approve? (y/n)" 프롬프트 없이 즉시 실행합니다.

**왜 YOLO 모드를 사용하나요?** 주로 **AI의 작업을 신뢰할 때** 속도와 편의성을 위해서입니다. 숙련된 사용자들은 반복적이고 안전한 작업을 많이 할 때 YOLO를 켤 수 있습니다. 예를 들어 Gemini에게 10개의 서로 다른 파일을 차례로 생성하도록 요청하는 경우, 각각을 승인하는 것은 흐름을 늦출 수 있습니다. YOLO 모드는 이 모든 것이 자동으로 작성되도록 합니다. 또 다른 시나리오는 완전히 자동화된 스크립트나 CI 파이프라인에서 Gemini CLI를 사용하는 것입니다. 확인을 위해 일시 중지되지 않도록 `--yolo`와 함께 헤드리스로 실행할 수 있습니다.

처음부터 YOLO 모드로 시작하려면 다음을 사용하여 CLI를 실행하세요:

```bash
gemini --yolo
```

또는 짧은 형식인 `gemini -y`를 사용하세요. CLI에 자동 승인이 켜져 있다는 표시(다른 프롬프트나 알림 등)가 나타납니다. 대화형 세션 중에는 언제든지 **Ctrl+Y**를 눌러 전환할 수 있으며, CLI는 보통 하단에 "YOLO mode enabled (all actions auto-approved)"와 같은 메시지를 표시합니다.

**강력한 경고:** YOLO 모드는 강력하지만 **위험**합니다. Gemini 팀 스스로 "대담한 사용자"를 위한 것이라고 명시했습니다. 즉, AI가 묻지도 않고 위험한 명령을 실행할 가능성이 있음을 인지해야 합니다. 일반 모드에서 AI가 `rm -rf /`를 실행하기로 결정했다면(최악의 시나리오), 당연히 거절할 것입니다. YOLO 모드에서는 해당 명령이 즉시 실행되어 시스템을 망가뜨릴 것입니다. 그러한 극단적인 실수는 드물지만(AI의 시스템 프롬프트에 안전 가이드라인이 포함되어 있음), 확인의 핵심은 원치 않는 동작을 잡아내는 것입니다. YOLO는 그 안전망을 제거합니다.

**YOLO를 위한 베스트 프랙티스:** 완전한 위험 없이 편의성을 원한다면 특정 명령을 **허용 목록(allow-list)**에 추가하는 것을 고려해 보세요. 예를 들어 설정에서 특정 도구나 명령 패턴은 확인이 필요하지 않도록 구성할 수 있습니다(예: 모든 `git` 명령이나 읽기 전용 작업 허용). 실제로 Gemini CLI는 특정 명령에 대해 확인을 건너뛰는 구성을 지원합니다. 예를 들어 `"tools.shell.autoApprove": ["git ", "npm test"]`와 같이 설정하여 해당 명령들은 항상 실행되도록 할 수 있습니다. 이렇게 하면 전역적으로 YOLO 모드가 필요하지 않을 수 있으며, 안전한 명령만 선택적으로 YOLO할 수 있습니다. 또 다른 방법: YOLO를 사용할 때 Docker 나 컨테이너에서 Gemini를 실행하여 AI가 무엇을 하든 시스템이 격리되도록 하는 것입니다(Gemini에는 도커 컨테이너에서 도구를 실행하는 `--sandbox` 플래그가 있습니다).

많은 고급 사용자들은 사소한 파일 편집이나 쿼리를 연달아 수행할 때는 YOLO를 켰다가, 중요한 작업을 하기 전에는 끄는 방식으로 자주 전환합니다. 키보드 단축키를 사용하여 빠르게 전환하며 똑같이 할 수 있습니다.

요약하자면, **YOLO 모드는 감독을 대가로 마찰을 제거합니다.** 아껴서 현명하게 사용해야 할 프로 기능입니다. 이는 AI에 대한 신뢰(혹은 무모함!)를 진정으로 보여줍니다. Gemini CLI를 처음 사용한다면 AI가 주로 어떤 행동을 하는지 명확히 이해할 때까지 YOLO를 피하는 것이 좋습니다. 사용하게 된다면 버전 관리나 백업을 철저히 하세요. 만약을 위해서 말이죠.

*(위안이 될지 모르겠지만, 혼자가 아닙니다 - 커뮤니티의 많은 이들이 "YOLO를 켰더니 Gemini가 미친 짓을 했어"라며 농담을 주고받곤 합니다. 그러니 사용하되... 음, 인생은 한 번뿐이니까요.)*

## 팁 11: 헤드리스 및 스크립팅 모드 (백그라운드에서 Gemini CLI 실행)

**빠른 사용 사례:** 명령줄 인수나 환경 변수를 통해 프롬프트(또는 전체 대화)를 제공하여 Gemini CLI를 스크립트나 자동화에 사용할 수 있습니다. Gemini CLI는 출력을 생성하고 종료됩니다. 다른 도구와 통합하거나 일정에 따라 AI 작업을 트리거하는 데 좋습니다.

REPL을 열지 않고 일회성 답변을 얻기 위해 `gemini -p "...prompt..."`를 사용할 수 있음을 이미 보았습니다. 이것이 바로 헤드리스 사용입니다. 모델의 응답을 출력하고 셸로 돌아갑니다. 하지만 더 많은 일을 할 수 있습니다:

* **시스템 프롬프트 재정의:** 기본값과 다른 커스텀 시스템 페르소나 또는 지침 세트로 Gemini CLI를 실행하려면 환경 변수 `GEMINI_SYSTEM_MD`를 사용하세요. 이를 설정하면 Gemini CLI가 내장된 시스템 프롬프트를 무시하고 제공된 파일을 대신 사용합니다. 예를 들어:

    ```bash
    export GEMINI_SYSTEM_MD="/path/to/custom_system.md"
    gemini -p "매우 주의 깊게 작업 X를 수행해 줘"
    ```

    이렇게 하면 프롬프트를 실행하기 전에 `custom_system.md`를 시스템 프롬프트(AI가 따르는 "역할" 및 규칙)로 로드합니다. 또는 `GEMINI_SYSTEM_MD=true`로 설정하면 CLI는 현재 프로젝트의 `.gemini` 디렉토리에서 `system.md`라는 파일을 찾습니다. 이 기능은 매우 고급 기능입니다. 기본적으로 CLI의 "두뇌"를 사용자 정의 지침으로 교체할 수 있게 해주며, 일부 사용자들은 이를 특수 워크플로우(예: 특정 페르소나 시뮬레이션 또는 엄격한 정책 강제)를 위해 사용합니다. 핵심 프롬프트를 교체하면 도구 사용에 영향을 줄 수 있으므로 주의해서 사용하세요(핵심 프롬프트에는 AI가 도구를 선택하고 사용하는 방법에 대한 중요한 지시가 포함되어 있습니다).

* **CLI를 통한 직접 프롬프트:** `-p` 외에도 초기 프롬프트와 함께 세션을 시작하고 계속 열어두는 `-i`(대화형 프롬프트)가 있습니다. 예를 들어: `gemini -i "안녕, 무언가를 디버깅해 보자"`는 REPL을 열고 모델에게 이미 인사를 건넨 상태가 됩니다. 시작할 때 첫 질문을 즉시 던지고 싶을 때 유용합니다.

* **셸 파이프를 사용한 스크립팅:** 텍스트뿐만 아니라 파일이나 명령 출력도 Gemini로 파이프할 수 있습니다. 예를 들어: `gemini -p "이 로그를 요약해 줘:" < big_log.txt`는 "이 로그를 요약해 줘:"라는 문구 뒤에 `big_log.txt`의 내용을 프롬프트에 입력합니다. 또는 `some_command | gemini -p "위의 출력을 고려할 때 무엇이 잘못되었나요?"`와 같이 할 수 있습니다. 이 기술을 사용하면 유닉스 도구와 AI 분석을 결합할 수 있습니다. 단일 패스 작업이라는 점에서 헤드리스입니다.

* **CI/CD에서 실행:** Gemini CLI를 빌드 프로세스에 통합할 수 있습니다. 예를 들어, CI 파이프라인에서 테스트를 실행한 다음 Gemini CLI를 사용하여 실패한 테스트 출력을 자동으로 분석하고 의견을 게시할 수 있습니다. `-p` 플래그와 환경 인증을 사용하면 이를 스크립팅할 수 있습니다. (물론 환경에 API 키나 필요한 인증이 있는지 확인해야 합니다.)

한 가지 더 헤드리스 요령: **`--format=json` 플래그**(또는 설정). Gemini CLI는 사람이 읽을 수 있는 텍스트 대신 JSON 형식으로 응답을 출력하도록 구성할 수 있습니다. 이는 프로그래밍 방식의 소비에 유용합니다. 스크립트가 JSON을 파싱하여 답변이나 도구 작업 세부 정보를 얻을 수 있습니다.

**헤드리스 모드가 중요한 이유:** 이는 Gemini CLI를 대화형 어시스턴트에서 다른 프로그램이 호출할 수 있는 **백엔드 서비스** 또는 유틸리티로 변환합니다. 매일 밤 Gemini CLI 프롬프트를 실행하는 크론잡(cronjob)을 예약할 수 있습니다(AI 로직으로 보고서를 생성하거나 무언가를 정리하는 것을 상상해 보세요). 특정 작업을 위해 헤드리스 Gemini 실행을 트리거하는 버튼을 IDE에 연결할 수도 있습니다.

**예시:** 뉴스 웹사이트의 일일 요약을 원한다고 가정해 봅시다. 다음과 같은 스크립트를 가질 수 있습니다:

```bash
gemini -p "Web-fetch \"https://news.site/top-stories\" and extract the headlines, then write them to headlines.txt"
```

아마도 `--yolo`와 함께 사용하면 파일 쓰기 확인을 묻지 않을 것입니다. 이는 웹 가져오기 도구를 사용하여 페이지를 가져오고 파일 쓰기 도구를 사용하여 헤드라인을 저장합니다. 모든 것이 자동으로 이루어지며 사람이 개입할 필요가 없습니다. Gemini CLI를 스크립팅 가능한 구성 요소로 취급하면 가능성은 무궁무진합니다.

요약하자면, **헤드리스 모드**는 자동화를 가능하게 합니다. 이는 Gemini CLI와 다른 시스템 사이의 다리입니다. 이를 마스터한다는 것은 터미널에서 타이핑할 때뿐만 아니라, 자리에 없을 때도 AI 에이전트가 사용자를 위해 일할 수 있도록 AI 사용을 확장할 수 있음을 의미합니다.

*(팁: 정말 오래 실행되는 비대화형 작업의 경우 Gemini CLI의 "Plan" 모드나 개입 없이 다단계 계획을 생성하는 방법도 살펴볼 수 있습니다. 하지만 이는 이 가이드의 범위를 벗어나는 고급 주제입니다. 대부분의 경우 헤드리스 모드를 통한 잘 작성된 단일 프롬프트로도 많은 것을 달성할 수 있습니다.)*

## 팁 12: 채팅 세션 저장 및 재개

**빠른 사용 사례:** Gemini CLI로 한 시간 동안 문제를 디버깅하다가 멈춰야 하는 경우, 대화 컨텍스트를 잃을 필요가 없습니다. `/chat save <name>`을 사용하여 세션을 저장하세요. 나중에(CLI를 재시작한 후에도) `/chat resume <name>`을 사용하여 중단한 부분부터 다시 시작할 수 있습니다. 이렇게 하면 장기 대화도 원활하게 일시 중지하고 계속할 수 있습니다.

Gemini CLI에는 기본적으로 내장된 채팅 세션 관리자가 있습니다. 알아두어야 할 명령어는 다음과 같습니다:

* `/chat save <tag>` - 현재 대화 상태를 제공한 태그/이름 아래에 저장합니다. 태그는 해당 세션의 파일 이름이나 키와 같습니다. 원할 때 자주 저장하세요. 태그가 이미 존재하면 덮어씁니다. (설명적인 이름을 사용하는 것이 도움이 됩니다 - 예: `chat save fix-docker-issue`)
* `/chat list` - 저장된 모든 세션(사용한 태그들)을 나열합니다. 이전에 저장한 이름이 무엇인지 기억하는 데 도움이 됩니다.
* `/chat resume <tag>` - 해당 태그의 세션을 재개하여 전체 대화 컨텍스트와 히스토리를 저장 당시의 상태로 복구합니다. 마치 떠난 적이 없는 것처럼요. 그런 다음 해당 시점부터 채팅을 계속할 수 있습니다.
* `/chat share` - (파일로 저장) 다른 사람이 세션을 계속할 수 있도록 전체 채팅을 공유할 때 유용합니다. 거의 협업과 같습니다.

내부적으로 이러한 세션은 `~/.gemini/chats/` 또는 유사한 위치에 저장될 가능성이 높습니다. 대화 메시지와 관련 상태가 포함됩니다. 이 기능은 다음과 같은 경우에 매우 유용합니다:

* **긴 디버깅 세션:** 때로는 AI와의 디버깅이 긴 대화가 될 수 있습니다. 한 번에 해결할 수 없다면 저장하고 나중에(아마도 맑은 정신으로) 다시 돌아오세요. 전체 컨텍스트가 다시 로드되므로 AI는 이전의 모든 내용을 여전히 "기억"합니다.
* **다일 작업:** Gemini CLI를 프로젝트 어시스턴트로 사용하는 경우, 며칠에 걸친 "모듈 X 리팩토링"을 위한 하나의 채팅 세션을 가질 수 있습니다. 매일 해당 특정 채팅을 재개하여 컨텍스트가 매일 초기화되지 않도록 할 수 있습니다. 한편, "문서 작성"을 위한 다른 세션을 별도로 저장해 둘 수도 있습니다. 컨텍스트 전환은 하나를 저장하고 다른 하나를 재개하는 문제일 뿐입니다.
* **팀 핸드오프:** 이것은 더 실험적이지만, 이론적으로 저장된 채팅 내용을 동료와 공유할 수 있습니다(저장된 파일은 이식 가능할 가능성이 높음). 동료가 이를 자신의 `.gemini` 디렉토리에 넣고 재개하면 동일한 컨텍스트를 볼 수 있습니다. 협업을 위한 **더 실용적이고 간단한 접근 방식**은 로그에서 관련 Q&A를 복사하고 공유된 `GEMINI.md` 또는 프롬프트를 사용하는 것이지만, 세션 데이터가 사용자 소유라는 점을 주목할 가치가 있습니다.

**사용 예시:**

```bash
/chat save api-upgrade
```

*(세션이 "api-upgrade"로 저장됨)*

```bash
/quit
```

*(나중에 CLI를 다시 염)*

```bash
$ gemini
gemini> /chat list
```

*(출력: api-upgrade)*

```bash
gemini> /chat resume api-upgrade
```

이제 모델이 마지막 대화 상태로 준비되어 인사를 건넵니다. 위로 스크롤하여 이전의 모든 메시지가 있는지 확인하여 확인할 수 있습니다.

**프로 팁:** 채팅을 저장할 때 의미 있는 태그를 사용하세요. `/chat save session1` 대신 주제와 관련된 이름(예: `/chat save memory-leak-bug`)을 지정하세요. 그러면 나중에 `/chat list`를 통해 적절한 세션을 찾는 데 도움이 됩니다. 저장할 수 있는 세션 수에 대해 발표된 엄격한 제한은 없지만, 정리를 위해 가끔 오래된 세션을 지우는 것이 현명할 수 있습니다.

이 기능은 Gemini CLI를 영구적인 조언자로 만들어줍니다. 대화에서 얻은 지식을 잃지 않고 언제든지 일시 중지하고 재개할 수 있습니다. 이는 닫을 때 컨텍스트를 잊어버리는 일부 다른 AI 인터페이스와 차별화되는 점입니다. 파워 유저에게 이는 **AI와 병렬적으로 여러 작업 스레드를 유지할 수 있음**을 의미합니다. 서로 다른 작업을 위해 여러 터미널 탭을 사용하는 것처럼, 여러 채팅 세션을 저장해 두고 필요할 때마다 재개하여 사용할 수 있습니다.

## 팁 13: 멀티 디렉토리 작업 공간 - 하나의 Gemini, 여러 폴더

**빠른 사용 사례:** 프로젝트가 여러 리포지토리나 디렉토리에 나뉘어 있나요? Gemini CLI를 실행할 때 *이 모든 폴더*에 한꺼번에 액세스하도록 설정하여 통합된 작업 공간을 보게 할 수 있습니다. 예를 들어 프론트엔드와 백엔드가 별도의 폴더인 경우, 두 폴더를 모두 포함하여 Gemini가 양쪽 모두의 파일을 참조하거나 편집하게 할 수 있습니다.

**멀티 디렉토리 모드**를 사용하는 두 가지 방법이 있습니다:

* **실행 플래그:** Gemini CLI를 시작할 때 `--include-directories` (또는 `-I`) 플래그를 사용하세요. 예를 들어:

    ```bash
    gemini --include-directories "../backend:../frontend"
    ```

    이는 `scripts` 디렉토리에서 명령을 실행하고 두 형제 폴더를 포함하고 싶다고 가정할 때입니다. 콜론으로 구분된 경로 목록을 제공합니다. Gemini CLI는 모든 디렉토리를 하나의 큰 작업 공간의 일부로 취급합니다.

* **지속적인 설정:** `settings.json`에서 `"includeDirectories": ["path1", "path2", ...]`를 정의할 수 있습니다. 이는 여러 프로젝트에서 사용하는 공유 라이브러리 폴더와 같이 항상 로드하고 싶은 공통 디렉토리가 있을 때 유용합니다. 경로는 상대 경로 또는 절대 경로일 수 있습니다. 경로에 `~/common-utils`와 같은 환경 변수를 사용하는 것도 허용됩니다.

멀티 디렉토리 모드가 활성화되면 CLI의 컨텍스트와 도구가 포함된 모든 위치의 파일을 고려합니다. `/directory show` 명령은 현재 작업 공간에 어떤 디렉토리가 있는지 나열합니다. 세션 중에 `/directory add <path>`를 사용하여 동적으로 디렉토리를 추가할 수도 있습니다. 그러면 시작할 때와 마찬가지로 컨텍스트를 위해 해당 디렉토리를 즉시 검색하고 로드합니다.

**멀티 디렉토리 모드를 왜 사용하나요?** 마이크로서비스 아키텍처나 모듈식 코드베이스에서는 코드 조각들이 서로 다른 리포지토리에 있는 경우가 흔합니다. 하나에서만 Gemini를 실행한다면 다른 쪽을 "볼" 수 없습니다. 이들을 결합하면 프로젝트 간 추론이 가능해집니다. 예를 들어, "백엔드의 새 API 엔드포인트에 맞춰 프론트엔드의 API 클라이언트를 업데이트해 줘"라고 요청할 수 있습니다. Gemini는 백엔드 폴더를 열어 API 정의를 확인하는 동시에 프론트엔드 코드를 열어 그에 맞게 수정할 수 있습니다. 멀티 디렉토리가 없다면 한 쪽씩 작업하고 정보를 수동으로 옮겨야 합니다.

**예시:** `client/`와 `server/`가 있다고 가정해 봅시다. 다음과 같이 시작합니다:

```bash
cd client
gemini --include-directories "../server"
```

이제 `gemini>` 프롬프트에서 `!ls`를 수행하면 `client`와 `server` 양쪽의 파일을 나열할 수 있음을 알게 됩니다. 다음과 같이 할 수 있습니다:

```bash
server/routes/api.py와 client/src/api.js를 나란히 열고 함수 이름을 비교해 줘.
```

AI는 두 파일 모두에 액세스할 수 있습니다. 또는 다음과 같이 말할 수 있습니다:

```bash
API가 변경됨: "/users/create" 엔드포인트가 이제 "/users/register"임. 백엔드와 프론트엔드를 모두 그에 맞게 업데이트해 줘.
```

백엔드 라우트에 패치를 생성하는 동시에 프론트엔드의 fetch 호출을 조정할 수 있습니다.

내부적으로 Gemini는 해당 디렉토리들의 파일 인덱스를 병합합니다. 각 디렉토리가 거대하다면 약간의 성능 고려 사항이 있을 수 있지만, 일반적으로 중소규모 프로젝트 여러 개는 문제없이 처리합니다.

**팁 속의 팁:** 멀티 디렉토리를 항상 사용하지 않더라도 프롬프트에서 절대 경로(`@/path/to/file`)로 파일 시스템 전체의 파일을 참조할 수 있습니다. 하지만 멀티 디렉토리가 없으면 Gemini가 해당 파일을 편집할 권한이 없거나 선제적으로 컨텍스트를 로드하는 방법을 모를 수 있습니다. 멀티 디렉토리는 범위에 공식적으로 포함시키므로 전체 세트에 대한 검색이나 코드 생성과 같은 작업에 대해 모든 파일을 인식하게 됩니다.

**디렉토리 제거:** 필요한 경우 `/directory remove <path>`를 통해 작업 공간에서 디렉토리를 제외할 수 있습니다. 실수로 무언가를 포함시킨 경우 유용합니다.

요약하자면, **멀티 디렉토리 모드는 컨텍스트를 통합합니다.** 여러 리포지토리로 구성된 프로젝트나 코드가 나뉘어 있는 모든 상황에서 필수적입니다. 이는 Gemini CLI가 전체 솔루션을 열어둔 IDE처럼 작동하게 만듭니다. 파워 유저에게 이는 프로젝트의 어떤 부분도 AI의 손길이 닿지 않는 곳이 없음을 의미합니다.

## 팁 14: AI 지원을 통한 파일 정리 및 정돈

**빠른 사용 사례:** 어지러운 `Downloads` 폴더나 정리되지 않은 프로젝트 에셋 때문에 피곤하신가요? Gemini CLI를 스마트 정리 도구로 고용할 수 있습니다. 디렉토리 개요를 제공하면 파일을 분류하고 (사용자의 승인을 받아) 하위 폴더로 옮길 수도 있습니다. 예를 들어, "내 `Downloads` 폴더를 정리해 줘: 이미지는 `Images` 폴더로, PDF는 `Documents`로 옮기고 임시 파일은 삭제해 줘."

Gemini CLI는 파일 이름, 크기를 읽고 파일 내용까지 들여다볼 수 있으므로 파일 정리에 대해 정보에 입각한 결정을 내릴 수 있습니다. 커뮤니티에서 만든 **"Janitor AI"**라는 도구가 이를 잘 보여줍니다. Gemini CLI를 통해 파일을 중요 파일과 정크 파일로 분류하고 그에 따라 그룹화합니다. 특히 정크 파일을 자동으로 삭제하지 않고 검토를 위해 `Trash` 폴더로 옮기는 방식을 사용했습니다.

이러한 워크플로우를 Gemini CLI에서 수동으로 복제하는 방법은 다음과 같습니다:

1.  **디렉토리 조사:** 프롬프트를 사용하여 Gemini가 나열하고 분류하게 합니다. 예를 들어:
    ```bash
    현재 디렉토리의 모든 파일을 나열하고 "이미지", "비디오", "문서", "아카이브" 또는 "기타"로 분류해 줘.
    ```
    Gemini는 `!ls` 등을 사용하여 파일 목록을 가져온 다음 이름/확장자를 분석하여 카테고리를 생성합니다.
2.  **정리 계획 수립:** Gemini에게 어떻게 재정리할지 묻습니다. 예를 들어:
    ```bash
    이 파일들을 위한 새 폴더 구조를 제안해 줘. 유형별(Images, Videos, Documents 등)로 구분하고 싶어. 또한 중복되거나 불필요해 보이는 파일도 식별해 줘.
    ```
    AI는 계획을 제시할 것입니다: 예: *"Images/, Videos/, Documents/, Archives/ 폴더를 만듭니다. X.png, Y.jpg는 Images/로 옮기고, A.mp4는 Videos/로 옮깁니다. temp.txt는 불필요해 보입니다."*
3.  **확인 후 이동 실행:** 그런 다음 계획을 실행하도록 지시할 수 있습니다. 각 파일에 대해 `mv`와 같은 셸 명령을 사용할 수 있습니다. 파일 시스템을 수정하므로 각 명령에 대해 확인 프롬프트가 나타납니다(YOLO 모드가 아닌 경우). 이동을 주의 깊게 승인하세요. 완료되면 디렉토리가 제안된 대로 깔끔하게 정리될 것입니다.

과정 전반에 걸쳐 Gemini의 자연어 이해가 핵심입니다. 예를 들어 명시적으로 언급되지 않더라도 `IMG_001.png`가 이미지이거나 `presentation.pdf`가 문서임을 추론할 수 있습니다. 심지어 (비전 기능을 사용하여) 이미지를 열어 스크린샷인지, 사진인지, 아이콘인지 구분하고 그에 따라 이름을 짓거나 정렬할 수도 있습니다.

**내용에 따른 파일 이름 변경:** 특히 마법 같은 기능은 Gemini가 파일 내용을 보고 더 설명적인 이름으로 변경하게 하는 것입니다. Gemini는 **이미지를 스캔하고 내용에 따라 자동으로 이름을 변경**할 수 있습니다. 예를 들어 `IMG_1234.jpg`라는 파일이 로그인 화면 스크린샷임을 AI가 확인하면 `login_screen.jpg`로 이름을 바꿀 것을 제안할 수 있습니다. 이를 위해 다음과 같이 프롬프트를 보낼 수 있습니다:

```bash
여기 있는 각 .png 이미지를 보고, 그 내용을 설명하는 이름으로 변경해 줘.
```

Gemini는 각 이미지를 열고(비전 도구 사용), 설명을 얻은 다음 `mv IMG_1234.png login_screen.png` 작업을 제안할 것입니다. 이는 특히 디자인이나 사진 폴더에서 에셋 정리를 획기적으로 개선할 수 있습니다.

**2단계 접근 방식:** 먼저 광범위한 분류(중요 vs 정크 vs 기타)를 한 다음 그룹을 세분화하는 2단계 프로세스가 효과적입니다. 이를 에뮬레이션할 수 있습니다: 먼저 삭제할 가능성이 높은 파일(거대한 설치용 `.dmg` 파일이나 중복 파일 등)을 유지할 파일과 분리합니다. 그런 다음 유지할 파일을 정리하는 데 집중하세요. AI가 정크로 표시한 파일은 항상 다시 확인하세요. AI의 추측이 항상 옳지는 않을 수 있으므로 수동 감독이 필요합니다.

**안전 팁:** AI에게 파일 이동이나 삭제를 맡길 때는 백업을 해두거나 `/restore` 또는 직접 만든 백업을 통해 되돌릴 준비를 하세요. 드라이런(dry-run)을 하는 것도 현명합니다. Gemini에게 계획을 위해 실행할 명령을 실제로 실행하지 말고 출력만 해달라고 요청하여 검토하세요. 예: "이 계획에 필요한 `mv` 및 `mkdir` 명령 목록을 보여주되, 아직 실행하지는 마." 목록을 검토한 후에는 직접 복사해서 실행하거나 Gemini에게 진행하도록 지시할 수 있습니다.

이는 "뻔하지 않은" 작업에 Gemini CLI를 사용하는 주요 사례입니다. 단지 코딩뿐만 아니라 **AI의 영리함으로 시스템 가사 작업**을 하는 것입니다. 시간을 절약하고 혼란 속에 질서를 가져다줄 수 있습니다. 개발자로서 우리는 클러터(로그, 오래된 스크립트, 다운로드)를 쌓아두기 마련이며, AI 관리인은 꽤 유용할 수 있습니다.

## 팁 15: 컨텍스트 내 유지를 위해 긴 대화 압축하기

**빠른 사용 사례:** Gemini CLI와 오랫동안 대화했다면 모델의 컨텍스트 길이 제한에 도달하거나 세션이 너무 방대해졌다고 느낄 수 있습니다. `/compress` 명령을 사용하여 지금까지의 대화를 요약하고 전체 히스토리를 간결한 요약으로 대체하세요. 이렇게 하면 처음부터 다시 시작하지 않고도 더 많은 대화를 위한 공간을 확보할 수 있습니다.

대규모 언어 모델은 고정된 컨텍스트 창을 가지고 있습니다(Gemini 2.5 Pro는 매우 크지만 무한하지는 않습니다). 이를 초과하면 모델이 이전 메시지를 잊기 시작하거나 일관성을 잃을 수 있습니다. `/compress` 기능은 기본적으로 세션의 **AI 생성 요약(tl;dr)**으로, 중요한 지점들을 유지합니다.

**작동 방식:** `/compress`를 입력하면 Gemini CLI는 시스템 컨텍스트를 제외한 전체 대화를 가져와 요약을 생성합니다. 그런 다음 채팅 히스토리를 해당 요약(단일 시스템 또는 어시스턴트 메시지)으로 대체하여 필수 세부 사항은 보존하면서 세세한 대화 내용은 삭제합니다. 압축이 일어났음을 표시해 줍니다. 예를 들어 `/compress` 후에 다음과 같은 내용을 볼 수 있습니다:

--- 대화 압축됨 ---
논의 요약: 사용자 및 어시스턴트가 애플리케이션의 메모리 누수를 디버깅해 왔습니다. 주요 지점: 문제는 객체가 해제되지 않는 `DataProcessor.js`에 있을 가능성이 높습니다. 어시스턴트는 로깅 추가를 제안하고 무한 루프 가능성을 확인했습니다. 사용자는 수정을 테스트할 예정입니다.
--- 요약 끝 ---

그 시점부터 모델은 이 요약(및 새 메시지들)만을 이전에 일어난 일에 대한 컨텍스트로 가집니다. 요약이 핵심 정보를 잘 포착했다면 보통 이것으로 충분합니다.

**압축 시기:** 가급적 제한에 *도달하기 전*에 하는 것이 좋습니다. 세션이 길어지고 있다고 느껴지면(수백 번의 턴이 오갔거나 컨텍스트에 코드가 많을 때) 선제적으로 압축하세요. 컨텍스트가 최대치의 60%를 초과할 때와 같이 자동 압축 설정을 활성화할 수도 있습니다. 활성화된 경우 Gemini가 자동 압축 후 알려줄 것입니다. 그렇지 않다면 수동 `/compress`를 도구함에 두세요.

**압축 후:** 평소처럼 대화를 계속할 수 있습니다. 필요한 경우 매우 긴 세션에서 여러 번 압축할 수 있습니다. 매번 세밀함은 조금씩 사라지므로 아무 이유 없이 너무 자주 압축하지는 마세요. 복잡한 논의에 대해 너무 간략한 기억만 남게 될 수 있습니다. 하지만 일반적으로 모델 자신의 요약 능력은 핵심 사실을 유지하는 데 꽤 뛰어납니다(중요한 내용은 언제든지 직접 다시 언급할 수 있습니다).

**컨텍스트 창 예시:** 설명해 보겠습니다. 많은 파일을 참조하여 대규모 코드베이스를 입력하고 100만 토큰 컨텍스트(최대치)를 가졌다고 가정해 봅시다. 그런 다음 프로젝트의 다른 부분으로 넘어가고 싶을 때, 새로운 세션을 시작하여 그동안의 이해도를 모두 잃는 대신 압축할 수 있습니다. 요약은 코드에서 얻은 지식을 응축할 것입니다(예: "모듈 A, B, C를 로드했습니다. A는 이러한 함수들을 가지고 있습니다... B는 C와 이러한 방식으로 상호작용합니다..."). 이제 추상적으로 보존된 지식을 가지고 새로운 것에 대해 질문을 이어나갈 수 있습니다.

**메모리 vs 압축:** 압축은 장기 메모리에 저장되는 것이 아니라 해당 대화 내에서만 유지된다는 점에 유의하세요. *절대* 잃고 싶지 않은 사실이 있다면 팁 4(`/memory`에 추가)를 고려하세요. 메모리 항목은 `GEMINI.md` 컨텍스트에 있으므로 압축 후에도 유지됩니다(어쨌든 다시 삽입되기 때문입니다). 압축은 일시적인 채팅 내용에 더 가깝습니다.

**사소한 주의 사항:** 압축 후에는 AI가 요약된 "새로운" 대화를 보고 있는 것과 같으므로 스타일이 약간 변할 수 있습니다. 다시 자기소개를 하거나 어조가 바뀔 수 있습니다. "여기서부터 계속해 줘... (방금 압축했어)"와 같이 지시하여 부드럽게 이어가게 할 수 있습니다. 실제로는 대개 잘 이어집니다.

요약하자면(말장난입니다), **세션이 길어짐에 따라 `/compress`를 사용하여** 성능과 관련성을 유지하세요. 이는 Gemini CLI가 대화 히스토리의 모든 세부 사항 대신 더 큰 그림에 집중하도록 돕습니다. 이렇게 하면 AI가 쓰는 "정신적 종이"가 부족해지는 일 없이 마라톤 디버깅 세션이나 광범위한 설계 논의를 진행할 수 있습니다.

## 팁 16: `!`를 사용한 셸 명령 패스스루 (터미널과 대화하기)

**빠른 사용 사례:** Gemini CLI 세션 중 언제든지 `!`를 앞에 붙여 실제 셸 명령을 실행할 수 있습니다. 예를 들어 git 상태를 확인하고 싶다면 `!git status`를 입력하면 터미널에서 실행됩니다. 이는 창을 바꾸거나 컨텍스트를 전환할 필요를 없애줍니다. 여전히 Gemini CLI 안에 있으면서 "잠깐 이 명령만 실행해 줘"라고 말하는 것과 같습니다.

이 팁은 Gemini CLI의 **셸 모드**에 관한 것입니다. 이를 사용하는 두 가지 방법이 있습니다:

* **단일 명령:** 프롬프트 시작 부분에 `!`를 넣고 그 뒤에 명령과 인수를 입력하세요. 그러면 현재 작업 디렉토리에서 해당 명령이 실행되고 출력이 인라인으로 표시됩니다. 예를 들어:
    ```bash
    !ls -lh src/
    ```
    명령은 `src` 디렉토리의 파일을 나열하고 일반 터미널에서 보는 것과 같은 내용을 출력합니다. 출력 후 Gemini 프롬프트가 돌아와 대화를 계속하거나 더 많은 명령을 내릴 수 있습니다.
* **지속적인 셸 모드:** `!`만 입력하고 엔터를 치면 Gemini CLI가 하위 모드로 전환되어 셸 프롬프트(보통 `shell>` 등으로 표시됨)가 나타납니다. 이제 여러 셸 명령을 대화식으로 입력할 수 있습니다. 기본적으로 CLI 내부의 미니 셸입니다. 빈 라인에 `!`를 다시 입력하거나 `exit`를 입력하여 이 모드에서 나갈 수 있습니다. 예를 들어:
    ```bash
    !
    shell> pwd
    /home/alice/project
    shell> python --version
    Python 3.x.x
    shell> !
    ```
    마지막 `!` 후에 다시 일반 Gemini 프롬프트로 돌아옵니다.

**왜 유용한가요?** 개발은 작업과 문의의 혼합이기 때문입니다. AI와 무언가를 논의하다가 코드를 컴파일하거나 테스트를 실행하여 결과를 확인해야 할 때가 있습니다. 대화를 떠나는 대신 빠르게 실행하고 그 결과를 채팅에 다시 입력할 수 있습니다. 사실 Gemini CLI는 종종 도구 사용의 일부로 이를 대신 해줍니다(예를 들어 테스트를 수정해 달라고 하면 자동으로 `!pytest`를 실행할 수 있음). 하지만 사용자로서 수동으로 제어할 수 있는 모든 권한도 가지고 있습니다.

**예시:**

* Gemini가 코드 수정을 제안한 후, `!npm run build`를 실행하여 컴파일되는지 확인하고 오류가 있으면 복사하여 Gemini에게 도움을 요청할 수 있습니다.
* `vim`이나 `nano`에서 파일을 열고 싶다면 `!nano filename`을 통해 실행할 수 있습니다(다만 Gemini CLI 자체 인터페이스가 있으므로 내부에서 대화형 에디터를 사용하는 것은 다소 불편할 수 있습니다. 내장 에디터 통합을 사용하거나 에디터로 복사하는 것이 좋습니다).
* AI를 위한 정보를 수집하기 위해 셸 명령을 사용할 수 있습니다: 예: `!grep TODO -R .`로 프로젝트의 모든 TODO를 찾은 다음, Gemini에게 해당 TODO들을 해결하는 데 도움을 요청할 수 있습니다.
* 또는 단순히 환경 작업에 사용하세요: CLI를 떠나지 않고 필요한 경우 `!pip install some-package` 등을 수행할 수 있습니다.

**매끄러운 상호작용:** 한 가지 멋진 측면은 대화에서 출력을 참조할 수 있다는 점입니다. 예를 들어 `!curl http://example.com`을 실행하여 데이터를 가져와 출력을 확인한 다음 즉시 Gemini에게 "위의 출력을 JSON으로 포맷해 줘"라고 말할 수 있습니다. 출력이 채팅에 인쇄되었으므로 AI는 작업할 컨텍스트로 이를 가집니다(너무 크지 않은 경우).

**터미널을 기본 셸로 사용:** 항상 명령 앞에 `!`를 붙이고 있다면 아예 셸 모드를 기본으로 지속시킬 수 있습니다. 한 가지 방법은 특정 도구 모드로 Gemini CLI를 시작하는 것입니다. 하지만 더 쉬운 방법은 수동 명령을 많이 실행하고 가끔만 AI와 대화할 계획이라면 세션 시작 시 셸 모드(내용 없이 `!`)로 들어가는 것입니다. 그런 다음 질문을 하고 싶을 때마다 셸 모드에서 나오면 됩니다. 마치 AI를 즉시 사용할 수 있는 일반 터미널처럼 Gemini CLI를 사용하는 것과 같습니다.

**AI 계획과의 통합:** 때때로 Gemini CLI 자체가 셸 명령 실행을 제안할 것입니다. 사용자가 승인하면 사실상 `!command`와 동일한 작업을 수행합니다. 이를 이해하면 언제든지 개입할 수 있다는 것을 알 수 있습니다. Gemini가 막혔거나 무언가 시도해 보고 싶다면 제안할 때까지 기다릴 필요 없이 직접 실행하고 계속 진행할 수 있습니다.

요약하자면, `!` **패스스루**는 *셸 작업을 위해 Gemini CLI를 떠날 필요가 없음*을 의미합니다. AI와의 채팅과 시스템 명령 실행 사이의 경계를 무너뜨립니다. 파워 유저에게 이는 효율성을 극대화해 줍니다. AI와 터미널이 하나의 연속된 환경이 됩니다.

## 팁 17: 모든 CLI 도구를 잠재적인 Gemini 도구로 취급하기

**빠른 사용 사례:** Gemini CLI가 문제 해결 과정에서 시스템에 설치된 **어떤** 명령줄 도구든 활용할 수 있음을 인식하세요. AI는 셸에 액세스할 수 있으므로 `cURL`, `ImageMagick`, `git`, `Docker` 또는 다른 도구가 있다면 Gemini는 적절할 때 이를 호출할 수 있습니다. 즉, *여러분의 전체 `$PATH`가 AI의 도구 상자*입니다. 이는 내장 도구를 훨씬 넘어서는 기능을 확장해 줍니다.

예를 들어 "이 폴더의 모든 PNG 이미지를 WebP 형식으로 변환해 줘"라고 요청한다고 합시다. ImageMagick의 `convert` 유틸리티가 설치되어 있다면 Gemini CLI는 각 파일에 대해 `convert` 명령을 사용하는 셸 루프와 같은 계획을 세울 수 있습니다. 실제로 블로그의 초기 예시 중 하나는 사용자가 이미지 일괄 변환을 요청했고 Gemini가 `convert` 도구를 사용한 셸 한 줄 명령어를 실행하는 모습을 보여주었습니다.

또 다른 시나리오: "내 앱을 Docker에 배포해 줘." 만약 `Docker CLI`가 있다면 AI는 필요한 대로 `docker build` 및 `docker run` 단계를 호출할 수 있습니다. 또는 "FFmpeg를 사용하여 `video.mp4`에서 오디오를 추출해 줘"라고 하면 `ffmpeg` 명령을 구성할 수 있습니다.

이 팁은 사고방식에 관한 것입니다: **Gemini는 자신에게 코딩된 기능에 국한되지 않습니다.** 목표를 달성하기 위해 사용 가능한 다른 프로그램을 사용하는 방법을 알아낼 수 있습니다. 일반적인 구문을 알고 있으며 필요한 경우 도움말 텍스트를 읽을 수도 있습니다(도구에 대해 `--help`를 호출할 수 있음). 유일한 제한은 안전입니다. 기본적으로 시스템을 변경하는 모든 `run_shell_command`에 대해 확인을 요청합니다. 하지만 익숙해짐에 따라 특정 안전한 명령은 자동으로 허용하도록 설정할 수 있습니다(YOLO 또는 허용 도구 설정 참조).

**환경에 유의하세요:** "큰 힘에는 큰 책임이 따릅니다." 모든 셸 도구를 사용할 수 있으므로 AI가 의도치 않게 실행하기를 원하지 않는 프로그램이 `$PATH`에 포함되지 않도록 해야 합니다. 여기서 팁 19(커스텀 PATH)가 등장합니다. 일부 사용자들은 파괴적인 시스템 명령을 직접 호출하거나 무한 루프를 방지하기 위해(예: Gemini 내부에서 Gemini를 호출) Gemini를 위한 제한된 `$PATH`를 만듭니다. 기본적으로 `gcc`, `terraform` 등이 `$PATH`에 있다면 Gemini가 이를 호출할 수 있습니다. 작업이 필요로 할 때만 호출하겠지만, 가능성은 열려 있습니다.

**사고 과정 예시:** Gemini CLI에게 "현재 디렉토리를 서비스하는 기본 HTTP 서버를 설정해 줘"라고 요청한다고 상상해 보세요. AI는 "이를 위해 Python의 내장 서버를 사용할 수 있겠군"이라고 생각할 수 있습니다. 그런 다음 `!python3 -m http.server 8000`을 실행합니다. 시스템 도구(Python)를 사용하여 서버를 시작한 것입니다. 이는 무해한 예시입니다. 다른 예로 "이 리눅스 시스템의 메모리 사용량을 확인해 줘"라고 하면 `free -h` 명령을 사용하거나 `/proc/meminfo`를 읽을 수 있습니다. 시스템 관리자가 하듯이 사용 가능한 명령을 사용하는 것입니다.

**모든 도구는 AI의 확장입니다:** 이는 다소 미래 지향적이지만, 어떤 명령줄 프로그램이든 AI가 능력을 확장하기 위해 호출할 수 있는 "함수"로 볼 수 있습니다. 수학 문제를 풀어야 하나요? `bc`(계산기)를 호출할 수 있습니다. 이미지를 조작해야 하나요? 이미지 처리 도구를 호출할 수 있습니다. 데이터베이스를 쿼리해야 하나요? CLI 클라이언트가 설치되어 있고 자격 증명이 있다면 이를 사용할 수 있습니다. 가능성은 방대합니다. 다른 AI 에이전트 프레임워크에서는 이를 도구 사용(tool use)이라고 하며, Gemini CLI는 에이전트가 적절한 도구를 결정하도록 신뢰하도록 설계되었습니다.

**문제가 발생할 때:** 반대로 AI가 도구를 잘못 이해하거나 잘못된 플래그를 사용하여 환각을 일으킬 수 있습니다. 존재하지 않는 명령을 호출하려고 시도하여 오류가 발생할 수 있습니다. 이는 큰 문제가 아닙니다. 오류를 확인하고 수정하거나 명확히 설명해 줄 수 있습니다. 사실 Gemini CLI의 시스템 프롬프트는 맹목적으로 실행하기보다 먼저 계획(명령 제안)을 세우도록 안내합니다. 따라서 사용자가 이를 잡아낼 기회가 많습니다. 시간이 지남에 따라 개발자들은 이러한 실수를 줄이기 위해 도구 선택 로직을 개선하고 있습니다.

핵심 요점은 **Gemini CLI가 매우 큰 스위스 아미 나이프를 가지고 있다고 생각하는 것**입니다. 내장된 칼날뿐만 아니라 OS의 모든 도구가 포함되어 있습니다. 표준적인 도구라면 사용법을 일일이 가르칠 필요가 없습니다. 대개 이미 알고 있거나 알아낼 수 있습니다. 이는 여러분이 성취할 수 있는 것을 크게 증폭시킵니다. 설치된 거의 모든 프로그램을 실행할 수 있는 주니어 개발자나 데브옵스 엔지니어를 곁에 둔 것과 같습니다.

파워 유저로서 Gemini에게 더 많은 권한을 주기 위해 추가적인 CLI 도구를 설치할 수도 있습니다. 예를 들어 클라우드 서비스용 CLI(AWS CLI, GCloud CLI 등)를 설치하면 이론적으로 Gemini가 이를 사용하여 클라우드 리소스를 관리할 수 있습니다. 강력한 도구를 사용할 때는 항상 실행되는 명령을 이해하고 신뢰해야 합니다(실수로 거대한 클라우드 인스턴스를 가동하는 것은 원치 않을 것입니다). 하지만 현명하게 사용한다면 **"모든 것이 Gemini 도구"**라는 개념은 여러분이 환경에 통합함에 따라 Gemini CLI를 *기하급수적으로* 더 유능하게 만들어 줄 것입니다.

## 팁 18: 멀티모달 AI 활용 - Gemini가 이미지 등을 보게 하기

**빠른 사용 사례:** Gemini CLI는 텍스트에 국한되지 않고 멀티모달입니다. 즉, 이미지, 다이어그램, 심지어 제공된 경우 PDF까지 분석할 수 있습니다. 이를 유리하게 활용하세요. 예를 들어 "여기 오류 대화 상자 스크린샷 `@./error.png`이 있어 - 이 문제를 해결하는 데 도움을 줘"라고 말할 수 있습니다. AI는 이미지를 "보고" 그에 따라 응답할 것입니다.

Google의 Gemini 모델의 두드러진 특징 중 하나는 이미지 이해 능력입니다. Gemini CLI에서 `@`로 이미지를 참조하면 모델은 이미지 데이터를 받습니다. 이미지의 내용에 대해 설명, 분류 또는 추론을 출력할 수 있습니다. 우리는 이미 내용에 따른 이미지 이름 변경(팁 14)과 스크린샷 설명(팁 7)에 대해 논의했습니다. 하지만 다른 창의적인 용도들도 고려해 보세요:

* **UI/UX 피드백:** 디자이너와 협업하는 개발자라면 UI 이미지를 넣고 Gemini에게 피드백을 요청하거나 코드를 생성하게 할 수 있습니다. "이 UI 목업 `@mockup.png`을 보고 React 컴포넌트 구조를 만들어 줘." 이미지 내의 요소(헤더, 버튼 등)를 식별하고 코드 개요를 작성할 수 있습니다.
* **이미지 정리:** 이름 변경 외에도 섞여 있는 이미지 폴더를 내용별로 정렬하고 싶을 수 있습니다. "`./photos/`에 있는 이미지들을 테마(예: 일몰, 산, 사람)별로 하위 폴더로 분류해 줘." AI는 각 사진을 보고 분류할 수 있습니다(이는 일부 사진 앱이 AI로 하는 일과 비슷하며, 이제 Gemini를 통해 자신만의 스크립트로 할 수 있습니다).
* **OCR 및 데이터 추출:** 오류 텍스트 스크린샷이나 문서 사진이 있다면 Gemini는 종종 그 안의 텍스트를 읽을 수 있습니다. 예를 들어 "`invoice.png`에서 텍스트를 추출하여 구조화된 형식으로 정리해 줘." Google Cloud 블로그 예시에서 보여주듯이, Gemini CLI는 일련의 송장 이미지를 처리하고 정보 표를 출력할 수 있습니다. 송장 사진에서 송장 번호, 날짜, 금액을 얻기 위해 OCR과 이해를 기본적으로 수행한 것입니다. 이는 고급 사용 사례이지만 내부의 멀티모달 모델로 충분히 가능합니다.
* **그래프나 차트 이해:** 그래프 스크린샷이 있다면 "이 차트의 주요 통찰력을 설명해 줘 `@chart.png`"라고 요청할 수 있습니다. 축과 추세를 해석할 수도 있습니다. 정확도는 다를 수 있지만 시도해 볼 만한 기능입니다.

이를 실용적으로 만들기 위해: 이미지를 `@`로 참조할 때 이미지가 너무 거대하지 않도록 하세요(모델이 어느 정도 큰 이미지는 처리할 수 있지만). CLI는 이를 인코딩하여 모델로 보냅니다. 응답에는 설명이나 추가 작업이 포함될 수 있습니다. 하나의 프롬프트에 텍스트와 이미지 참조를 섞어 쓸 수도 있습니다.

**비이미지 모달리티:** CLI와 모델은 잠재적으로 PDF와 오디오도 도구를 통해 변환하여 처리할 수 있습니다. 예를 들어 `@report.pdf`라고 하면 Gemini CLI는 내부적으로 PDF-to-text 도구를 사용하여 텍스트를 추출한 다음 요약할 수 있습니다. `@audio.mp3`라고 하고 트랜스크립트를 요청하면 오디오-투-텍스트 도구(음성 인식 기능 등)를 사용할 수 있습니다. 치트 시트에는 PDF, 오디오, 비디오 파일 참조가 지원된다고 나와 있는데, 이는 아마도 적절한 내부 도구나 API를 호출함으로써 가능할 것입니다. 따라서 "이 인터뷰 오디오를 전사해 줘: `@interview.wav`"와 같은 요청이 실제로 작동할 수 있습니다(지금 안 되더라도 음성-텍스트 변환을 위한 기본 Google API가 연결될 수 있으므로 곧 가능해질 것입니다).

**풍부한 출력:** 멀티모달은 또한 통합된 경우 AI가 응답으로 이미지를 반환할 수 있음을 의미합니다(CLI에서는 대개 직접 *표시*하지 않겠지만 이미지 파일을 저장하거나 ASCII 아트를 출력할 수 있습니다). MCP 기능은 도구가 이미지를 반환할 수 있다고 언급했습니다. 예를 들어 AI 드로잉 도구가 이미지를 생성하고 Gemini CLI가 이를 (파일을 열거나 링크를 주는 방식으로) 제시할 수 있습니다.

**중요:** CLI 자체는 텍스트 기반이므로 터미널에서 이미지를 직접 *볼* 수는 없습니다(ASCII 미리보기가 가능한 경우가 아니면). 단지 분석 내용만 받게 됩니다. 따라서 이는 주로 이미지를 보는 것이 아니라 읽는 것에 관한 것입니다. VS Code 통합을 사용 중이라면 채팅 뷰에서 이미지를 볼 수 있을 것입니다.

요약하자면, **Gemini CLI를 사용할 때 GUI의 "I"를 잊지 마세요.** 많은 경우 텍스트만큼이나 시각적인 정보도 잘 처리할 수 있습니다. 이는 시각적 디버깅, 디자인 도움, 스크린샷에서의 데이터 추출 등과 같은 워크플로우를 동일한 도구 아래에서 가능하게 합니다. 이는 다른 일부 CLI 도구들이 아직 갖추지 못한 차별점입니다. 모델이 개선됨에 따라 이 멀티모달 지원은 더욱 강력해질 것이므로 미리 활용해 볼 가치가 있는 미래 지향적 기술입니다.

## 팁 19: 안정성을 위해 `$PATH` (및 도구 가용성) 사용자 정의하기

**빠른 사용 사례:** Gemini CLI가 혼동을 일으키거나 엉뚱한 프로그램을 호출하는 경우가 있다면 맞춤형 `$PATH`로 실행하는 것을 고려해 보세요. 사용 가능한 실행 파일의 범위를 제한하거나 순서를 조정함으로써, AI가 의도하지 않은 유사한 이름의 스크립트를 호출하는 것을 방지할 수 있습니다. 본질적으로 알려진 정상 도구들로 도구 액세스 범위를 샌드박싱하는 것입니다.

대부분의 사용자에게 이는 문제가 되지 않지만, 커스텀 스크립트가 많거나 여러 버전의 도구를 사용하는 파워 유저에게는 도움이 될 수 있습니다. 개발자들이 언급한 한 가지 이유는 무한 루프나 이상 동작을 피하기 위해서입니다. 예를 들어 `gemini` 자체가 `$PATH`에 있다면 잘못된 AI가 Gemini 내부에서 Gemini를 재귀적으로 호출할 수도 있습니다(이론적으로 가능한 이상한 시나리오입니다). 또는 무언가와 충돌하는 `test`라는 이름의 명령이 있다면 AI가 엉뚱한 것을 호출할 수 있습니다.

**Gemini를 위한 PATH 설정 방법:** 실행 시 인라인으로 설정하는 것이 가장 쉽습니다:

```bash
PATH=/usr/bin:/usr/local/bin gemini
```

이렇게 하면 해당 디렉토리들로만 제한된 `$PATH`로 Gemini CLI가 실행됩니다. 실험적이거나 위험한 스크립트가 있는 디렉토리는 제외할 수 있습니다. 또는 `$PATH`를 정화하거나 조정한 다음 `gemini`를 실행하는 작은 셸 스크립트 래퍼를 만드세요.

또 다른 방법은 환경이나 구성을 사용하여 특정 도구를 명시적으로 비활성화하는 것입니다. 예를 들어 AI가 `rm`이나 파괴적인 도구를 절대 사용하지 않기를 원한다면, 아무것도 하지 않는 가짜 `rm`을 안전한 `$PATH`에 만들 수도 있습니다(하지만 이는 정상적인 작업도 방해할 수 있으므로 좋은 방법은 아닐 수 있습니다). 더 나은 방법은 설정의 **제외 목록(exclude list)**입니다. 확장 프로그램이나 `settings.json`에서 도구 이름을 제외할 수 있습니다. 예:

```json
"excludeTools": ["run_shell_command"]
```

이 극단적인 예시는 *모든* 셸 명령이 실행되는 것을 중단시킵니다(Gemini를 사실상 읽기 전용으로 만듭니다). 더 세밀하게는 특정 명령에 대해 확인을 건너뛰는 설정과 유사하게 다음과 같이 구성할 수 있습니다:

```json
"tools": {
  "exclude": ["apt-get", "shutdown"]
}
```

원칙은 환경을 제어함으로써 AI가 해서는 안 될 도구로 어리석은 짓을 할 위험을 줄이는 것입니다. 마치 집에 아동 안전 장치를 하는 것과 같습니다.

**무한 루프 방지:** 한 사용자 시나리오는 Gemini가 자신의 출력을 계속 읽거나 파일을 반복해서 다시 읽는 루프였습니다. 커스텀 `$PATH`가 로직 루프를 직접 해결할 수는 없지만, AI가 자신을 트리거하는 명령을 호출하는 것이 원인일 수 있습니다. AI가 (그럴 의도가 생겼을 때) 다른 AI 인스턴스를 실수로 생성하지 못하도록 (`bard`나 `gemini` 명령 호출 등) 하는 것이 좋습니다. `$PATH`에서 이를 제거하거나 해당 세션에 대해 이름을 바꾸는 것이 도움이 됩니다.

**샌드박스를 통한 격리:** `$PATH`를 건드리는 대신 Docker나 Podman을 사용하여 격리된 환경에서 도구를 실행하는 `--sandbox` 모드를 사용할 수도 있습니다. 이 경우 AI의 작업은 컨테이너 내에 갇히며 해당 샌드박스 이미지가 제공하는 도구만 사용할 수 있습니다. 엄선된 도구 세트가 포함된 Docker 이미지를 제공할 수 있습니다. 이는 과해 보일 수 있지만 매우 안전합니다.

**특정 작업을 위한 커스텀 PATH:** 프로젝트마다 서로 다른 `$PATH` 설정을 가질 수도 있습니다. 예를 들어 한 프로젝트에서는 특정 버전의 Node나 로컬 툴체인을 사용하기를 원할 수 있습니다. 해당 버전들을 가리키는 `$PATH`와 함께 `gemini`를 실행하면 AI가 올바른 버전을 사용하도록 보장할 수 있습니다. 기본적으로 Gemini CLI를 일반 사용자처럼 취급하세요. 여러분이 제공하는 환경은 무엇이든 사용합니다. 따라서 `gcc-10` 대신 `gcc-12`를 선택해야 한다면 그에 맞게 `$PATH`나 `CC` 환경 변수를 조정하세요.

**요약하자면:** *가드레일.* 파워 유저로서 AI의 작동 조건을 미세 조정할 수 있는 능력이 있습니다. 도구 사용과 관련된 바람직하지 않은 동작 패턴을 발견한다면 `$PATH`를 조정하는 것이 빠른 해결책이 될 수 있습니다. 일상적인 사용에는 필요 없겠지만 Gemini CLI를 자동화나 CI에 통합할 때 염두에 두어야 할 프로 팁입니다. 제어된 환경을 제공하세요. 그러면 무엇을 할 수 있고 무엇을 할 수 없는지 정확히 알 수 있어 신뢰성이 높아집니다.

---

## 팁 20: 토큰 캐싱 및 통계를 통한 토큰 지출 추적 및 감소

긴 채팅을 실행하거나 동일한 큰 파일을 반복해서 첨부하는 경우, 토큰 캐싱을 켜고 사용량을 모니터링하여 비용과 지연 시간을 줄일 수 있습니다. API 키 또는 Vertex AI 인증을 사용하면 Gemini CLI는 이전에 전송된 시스템 지침과 컨텍스트를 자동으로 재사용하므로 후속 요청 비용이 더 저렴해집니다. CLI에서 실시간으로 절감액을 확인할 수 있습니다.

**사용 방법**

캐싱을 활성화하는 인증 모드를 사용하세요. 토큰 캐싱은 Gemini API 키 또는 Vertex AI로 인증할 때 사용할 수 있습니다. 현재 OAuth 로그인으로는 사용할 수 없습니다.

사용량 및 캐시 히트를 검사하세요. 세션 중에 `stats` 명령을 실행하세요. 캐싱이 활성화된 경우 총 토큰 수와 `cached` 필드가 표시됩니다.

```bash
/stats
```

스크립트에서 메트릭을 캡처하세요. 헤드리스로 실행할 때 JSON으로 출력하고 각 모델에 대한 `tokens.cached`가 포함된 `stats` 블록을 파싱하세요:

```bash
gemini -p "README 요약해 줘" --output-format json
```

세션 요약을 파일로 저장하세요: CI나 예산 추적을 위해 JSON 세션 요약을 디스크에 기록하세요.

```bash
gemini -p "로그 분석해 줘" --session-summary usage.json
```

API 키나 Vertex 인증을 사용하면 CLI는 이전에 전송된 컨텍스트를 자동으로 재사용하므로 이후 턴에서는 더 적은 토큰을 보냅니다. `GEMINI.md`와 큰 파일 참조를 턴 전반에 걸쳐 안정적으로 유지하면 캐시 히트가 증가하며, 이는 통계에서 캐시된 토큰으로 반영됩니다.

## 팁 21: 빠른 클립보드 복사를 위해 `/copy` 사용하기

**빠른 사용 사례:** 불필요한 서식이나 라인 번호 없이 Gemini CLI의 최신 답변이나 코드 스니펫을 시스템 클립보드에 즉시 복사하세요. AI가 생성한 코드를 에디터에 빠르게 붙여넣거나 팀원과 결과를 공유할 때 완벽합니다.

Gemini CLI가 답변(특히 여러 줄의 코드 블록)을 제공할 때 이를 다른 곳에서 재사용하고 싶은 경우가 많습니다. `/copy` 슬래시 명령어는 CLI가 생성한 **마지막 출력물**을 클립보드에 직접 복사하여 이를 매우 간편하게 만들어 줍니다. 라인 번호나 프롬프트 텍스트까지 잡힐 수 있는 수동 선택과 달리, `/copy`는 순수한 응답 내용만 가져옵니다. 예를 들어 Gemini가 방금 50줄짜리 Python 스크립트를 생성했다면, `/copy`를 입력하는 것만으로 전체 스크립트를 클립보드에 담을 수 있습니다. 화면을 스크롤하며 텍스트를 선택할 필요가 없습니다. 내부적으로 Gemini CLI는 macOS의 `pbcopy`, 윈도우의 `clip` 등 플랫폼에 맞는 클립보드 유틸리티를 사용합니다. 명령어를 실행하면 확인 메시지가 표시되며, 그 후 필요한 곳에 바로 붙여넣을 수 있습니다.

**작동 방식:** `/copy` 명령어를 사용하려면 시스템에 클립보드 도구가 설치되어 있어야 합니다. macOS와 윈도우는 보통 기본적으로 설치되어 있습니다. 리눅스 사용자의 경우 `/copy` 기능이 작동하려면 `xclip`이나 `xsel`을 설치해야 할 수 있습니다. 설치가 확인되면 Gemini CLI가 답변을 출력한 후 언제든지 사용할 수 있습니다. 내용이 아무리 길어도 마지막 응답 전체를 캡처하며, 화면에 표시될 수 있는 내부 번호나 서식은 생략합니다. 이는 콘텐츠를 옮길 때 원치 않는 흔적들을 일일이 지워야 하는 수고를 덜어줍니다. 작은 기능이지만 AI가 생성한 코드로 작업하거나 보고서를 작성할 때 시간을 크게 절약해 주는 기능입니다.

**프로 팁:** 만약 `/copy` 명령어가 작동하지 않는다면 클립보드 유틸리티가 설치되어 있고 접근 가능한지 다시 확인해 보세요. 예를 들어 우분투 사용자는 `sudo apt install xclip`을 실행하여 기능을 활성화할 수 있습니다. 설정이 완료되면 `/copy`를 통해 Gemini의 출력물을 마찰 없이 복사하고 공유할 수 있습니다.

## 팁 22: 셸 모드 및 종료를 위한 `Ctrl+C` 마스터하기

**빠른 사용 사례:** 단 한 번의 키 입력으로 Gemini CLI를 깔끔하게 중단하거나 셸 모드에서 빠져나오세요. 그리고 빠르게 두 번 누르면 CLI를 완전히 종료할 수 있습니다. 이 다재다능한 **Ctrl+C** 단축키는 즉각적인 제어가 필요할 때 유용합니다.

Gemini CLI는 REPL처럼 작동하며, 작업을 중단하는 방법을 아는 것은 필수적입니다. **Ctrl+C**를 한 번 누르면 현재 동작이 취소되거나 입력 중인 내용이 지워집니다. 즉, "중단" 명령처럼 작동합니다. 예를 들어 AI가 너무 긴 답변을 생성하고 있어서 중간에 멈추고 싶다면 `Ctrl+C`를 누르세요. 생성이 즉시 중단됩니다. 프롬프트를 입력하다가 지우고 싶을 때도 `Ctrl+C`를 누르면 입력 줄이 깨끗해져서 새로 시작할 수 있습니다. 또한 `!`를 입력하여 들어간 **셸 모드**에서 `Ctrl+C`를 한 번 누르면 셸 모드를 종료하고 일반 Gemini 프롬프트로 돌아옵니다. 이는 셸 명령이 멈춰 있거나 빨리 AI 모드로 돌아가고 싶을 때 매우 유용합니다.

**Ctrl+C를 연속으로 두 번** 누르면 Gemini CLI가 완전히 종료됩니다. "한 번은 취소, 한 번 더 누르면 종료"라고 기억하세요. 이 더블 탭은 CLI 세션을 끝내라는 신호이며, 작별 메시지와 함께 프로그램이 닫힙니다. `/quit`을 입력하거나 터미널 창을 닫는 것보다 빠른 대안입니다. 지울 입력 내용이 있거나 중단할 작업이 있는 경우에는 한 번의 누름으로 종료되지 않으며, 프롬프트가 대기 상태일 때 두 번째 눌러야 완전히 나갈 수 있습니다. 이러한 설계는 현재 출력을 멈추려다가 실수로 세션까지 닫아버리는 일을 방지해 줍니다.

**프로 팁:** 셸 모드에서 **Esc** 키를 눌러도 CLI를 종료하지 않고 채팅 모드로 돌아갈 수 있습니다. 더 공식적인 종료를 원한다면 언제든지 `/quit` 명령어를 사용할 수 있습니다. 마지막으로 유닉스 사용자는 빈 프롬프트에서 **Ctrl+D**(EOF)를 눌러 종료할 수도 있으며, 필요한 경우 확인 메시지가 표시됩니다. 하지만 대부분의 경우 `Ctrl+C`의 싱글 및 더블 탭을 익히는 것이 가장 빠른 제어 방법입니다.

## 팁 23: `settings.json`으로 Gemini CLI 사용자 정의하기

**빠른 사용 사례:** 기본 설정에 머무르지 말고 `settings.json` 설정 파일을 편집하여 CLI의 동작과 외관을 취향이나 프로젝트 관례에 맞게 조정하세요. 이를 통해 모든 세션에서 테마, 도구 사용 규칙 또는 에디터 모드 등을 강제할 수 있습니다.

Gemini CLI는 설정 자유도가 매우 높습니다. 홈 디렉토리(`~/.gemini/`) 또는 프로젝트 폴더(리포지토리 내의 `.gemini/`)에 `settings.json` 파일을 만들어 기본 설정을 덮어쓸 수 있습니다. 시각적 테마부터 도구 권한까지 CLI의 거의 모든 측면을 여기서 조정할 수 있습니다. CLI는 시스템 전체 기본값, 사용자 설정, 프로젝트 전용 설정 순으로 설정을 병합하며, 프로젝트 설정이 가장 우선순위가 높습니다. 예를 들어 전역적으로는 다크 테마를 선호하지만, 특정 프로젝트에서는 더 엄격한 도구 샌드박싱이 필요할 때 각 수준의 `settings.json` 파일을 통해 이를 처리할 수 있습니다.

`settings.json` 내의 옵션은 JSON 키-값 쌍으로 지정됩니다. 다음은 유용한 사용자 정의 예시입니다:

```json
{
"theme": "GitHub",
"autoAccept": false,
"vimMode": true,
"sandbox": "docker",
"includeDirectories": ["../shared-library", "~/common-utils"],
"usageStatisticsEnabled": true
}
```

이 예시에서는 테마를 "GitHub"로 설정하고, 시스템을 변경할 수 있는 도구 실행 전 항상 묻도록 `autoAccept`를 끄고, 입력 에디터에 Vim 키바인딩을 활성화하고, 도구 샌드박싱을 위해 Docker 사용을 강제했습니다. 또한 Gemini가 공통 경로의 코드를 기본적으로 볼 수 있도록 작업 공간 컨텍스트에 디렉토리를 추가했습니다. 이러한 조정을 통해 Gemini CLI가 여러분의 워크플로우에 최적화되도록 할 수 있습니다.

설정을 편집하는 편리한 방법 중 하나는 내장된 설정 UI를 사용하는 것입니다. Gemini CLI에서 `/settings` 명령어를 실행하면 대화형 설정 에디터가 열립니다. 이 인터페이스에서는 설명을 보며 설정을 검색하고 브라우징할 수 있으며, 입력값 유효성 검사를 통해 JSON 구문 오류를 방지할 수 있습니다. 색상 변경, YOLO(자동 승인) 토글, 체크포인팅 동작 조정 등을 친숙한 메뉴를 통해 수행할 수 있습니다. 변경 사항은 `settings.json`에 저장되며, 일부는 즉시 적용되고 일부는 재시작이 필요할 수 있습니다.

**프로 팁:** 용도에 따라 프로젝트별로 별도의 `settings.json` 파일을 유지하세요. 예를 들어 팀 프로젝트에서는 위험한 작업을 막기 위해 `"sandbox": "docker"`와 `"excludeTools": ["run_shell_command"]`를 설정하고, 개인 프로젝트에서는 직접적인 셸 명령을 허용할 수 있습니다. Gemini CLI가 프로젝트 디렉토리 트리에서 가장 가까운 `.gemini/settings.json`을 자동으로 찾아 전역 설정과 병합합니다. 또한 시각적 설정을 빠르게 바꾸고 싶다면 파일 편집 대신 `/theme` 명령어를 사용하여 인터페이스에서 직접 테마를 전환해 보세요. 마음에 드는 것을 찾으면 `settings.json`에 넣어 영구적으로 적용할 수 있습니다.

## 팁 24: 컨텍스트 및 Diff를 위해 IDE 통합(VS Code) 활용하기

**빠른 사용 사례:** Gemini CLI를 VS Code에 연결하여 성능을 극대화하세요. CLI는 사용자가 현재 작업 중인 파일을 자동으로 인식하고, AI가 제안한 코드 변경 사항을 VS Code의 diff 에디터에서 바로 열어줍니다. 이를 통해 AI 어시스턴트와 코딩 작업 공간 사이의 원활한 루프가 생성됩니다.

Gemini CLI의 강력한 기능 중 하나는 Visual Studio Code와의 **IDE 통합**입니다. VS Code에 공식 *Gemini CLI Companion* 확장 프로그램을 설치하고 연결하면, Gemini CLI가 에디터의 상황을 인식할 수 있게 됩니다. 실제로는 어떤 의미일까요? 연결되면 Gemini는 현재 열려 있는 파일, 커서 위치, 그리고 선택한 텍스트를 알 수 있습니다. 이 모든 정보가 AI의 컨텍스트에 입력됩니다. 따라서 "이 함수를 설명해 줘"라고 물으면 Gemini CLI는 사용자가 강조 표시한 정확한 함수를 보고 답변할 수 있습니다. 최근에 열었던 최대 10개의 파일 정보와 선택 영역 정보가 공유되어 모델이 작업 공간을 풍부하게 이해하도록 돕습니다.

또 다른 큰 장점은 **네이티브 Diff 기능**입니다. Gemini CLI가 코드 수정을 제안하면(예: "이 함수를 리팩토링해 줘"라고 해서 패치를 생성한 경우), 해당 변경 사항을 VS Code의 diff 뷰어에서 자동으로 열 수 있습니다. VS Code에서 제안된 편집 내용을 나란히 비교하며 볼 수 있습니다. 익숙한 인터페이스를 사용하여 변경 사항을 검토하고, 수동으로 미세 조정한 다음 클릭 한 번으로 패치를 적용할 수 있습니다. CLI와 에디터는 동기화된 상태를 유지하므로, VS Code에서 diff를 수락하면 Gemini CLI도 이를 인지하고 해당 변경 사항이 적용된 상태로 세션을 계속합니다. 더 이상 터미널에서 에디터로 코드를 복사할 필요가 없습니다. AI의 제안이 개발 환경으로 직접 흘러 들어옵니다.

**설정 방법:** VS Code의 통합 터미널 안에서 Gemini CLI를 시작하면 VS Code를 감지하고 확장 프로그램 설치/연결을 자동으로 제안할 것입니다. 동의하면 필요한 `/ide install` 단계가 실행됩니다. 제안이 보이지 않는다면 Gemini CLI를 열고 `/ide install` 명령어를 실행하세요. 그러면 "Gemini CLI Companion" 확장 프로그램이 VS Code에 설치됩니다. 그 다음 `/ide enable`을 실행하여 연결을 설정하세요. 언제든지 `/ide status`를 통해 연결 상태와 추적 중인 파일 목록을 확인할 수 있습니다. 이제부터 Gemini CLI는 VS Code로부터 컨텍스트를 자동으로 받고 필요할 때 diff를 열어줍니다. 터미널에 살면서도 IDE의 모든 상황을 파악하는 AI 페어 프로그래머를 갖게 된 것입니다.

현재 VS Code가 이 통합을 지원하는 기본 에디터입니다. (VS Code 확장 프로그램을 지원하는 다른 에디터들도 작동할 수 있지만 공식적으로는 VS Code입니다.) 하지만 이 설계는 개방되어 있어 다른 에디터를 위한 유사한 통합을 개발할 수 있는 IDE Companion Spec이 존재합니다. 따라서 향후 커뮤니티 확장을 통해 IntelliJ나 Vim과 같은 IDE에 대한 최고 수준의 지원도 기대할 수 있습니다.

**프로 팁:** 연결이 완료되면 에디터를 떠나지 않고도 VS Code의 커맨드 팔레트를 사용하여 Gemini CLI를 제어할 수 있습니다. **Ctrl+Shift+P**(Mac은 Cmd+Shift+P)를 누르고 **"Gemini CLI: Run"**(새 세션 시작), **"Gemini CLI: Accept Diff"**(변경 승인 및 적용), **"Gemini CLI: Close Diff Editor"**(변경 거부)와 같은 명령어를 시도해 보세요. 이러한 단축키는 워크플로우를 더욱 간소화해 줍니다. 또한 항상 수동으로 CLI를 시작할 필요는 없습니다. 통합을 활성화하면 Gemini CLI는 VS Code 내부의 AI 공동 개발자가 되어 컨텍스트를 주시하며 필요할 때 도움을 줄 준비를 마칩니다.

## 팁 25: `Gemini CLI GitHub Action`으로 리포지토리 작업 자동화하기

**빠른 사용 사례:** Gemini를 GitHub에서 일하게 하세요. **Gemini CLI GitHub Action**을 사용하여 새로운 이슈를 자율적으로 분류하고 풀 리퀘스트를 검토하게 하면, 일상적인 개발 작업을 처리하는 AI 팀원을 둔 것과 같습니다.

Gemini CLI는 대화형 터미널 세션만을 위한 것이 아닙니다. GitHub Actions를 통해 CI/CD 파이프라인에서도 실행될 수 있습니다. Google은 리포지토리 워크플로우에 통합되는 **Gemini CLI GitHub Action**(현재 베타)을 제공하고 있습니다. 이는 프로젝트에 AI 에이전트를 배치하는 것과 같습니다. 리포지토리 이벤트에 의해 트리거되어 백그라운드에서 실행됩니다. 예를 들어 누군가 **새 이슈**를 생성하면 Gemini Action은 자동으로 이슈 설명을 분석하고, 관련 레이블을 추가하고, 우선순위를 정하거나 중복 이슈를 제안할 수 있습니다(지능형 이슈 분류 워크플로우). **풀 리퀘스트(PR)**가 열리면 Action이 작동하여 **AI 코드 리뷰**를 제공합니다. 코드 품질, 잠재적 버그 또는 스타일 개선 사항에 대한 통찰력을 PR에 댓글로 남깁니다. 이는 사람이 보기도 전에 관리자에게 즉각적인 피드백을 제공합니다. 가장 멋진 기능은 **온디맨드 협업**입니다. 팀원이 이슈나 PR 댓글에서 `@gemini-cli`를 멘션하고 "이 기능에 대한 유닛 테스트를 작성해 줘"와 같은 지침을 내리면, Action이 이를 포착하여 Gemini CLI가 요청을 이행하려고 시도합니다(예: 새 테스트가 포함된 커밋 추가).

설정은 간단합니다. 먼저 로컬에 Gemini CLI 버전 **0.1.18 이상**이 설치되어 있는지 확인하세요. 그런 다음 Gemini CLI에서 특수 명령인 `/setup-github`를 실행합니다. 이 명령어는 리포지토리에 필요한 워크플로우 파일을 생성하며 인증 과정을 안내합니다. 구체적으로는 `.github/workflows/` 아래에 YAML 파일을 추가합니다. 리포지토리의 Secrets에 Gemini API 키를 `GEMINI_API_KEY`로 추가해야 Action이 API를 사용할 수 있습니다. 워크플로우가 커밋되면 GitHub Action이 활성화되어 Gemini CLI가 새로운 이슈와 PR에 자율적으로 응답하기 시작합니다.

이 Action은 기본적으로 Gemini CLI를 자동화된 방식으로 실행하는 것이므로, 사용자의 취향에 맞게 사용자 정의할 수 있습니다. 기본적으로 제공되는 세 가지 워크플로우(이슈 분류, PR 리뷰, 멘션 트리거 어시스턴트)는 **완전한 오픈 소스이며 편집 가능**합니다. YAML을 수정하여 AI의 행동을 조정하거나 새 워크플로우를 추가할 수 있습니다. 예를 들어 매일 밤 최신 코드 변경 사항을 바탕으로 README를 업데이트하거나 오래된 의존성을 스캔하는 워크플로우를 만들 수 있습니다. 핵심적인 이점은 사소하거나 시간이 많이 걸리는 작업을 AI 에이전트에게 맡겨 개발자가 더 어려운 문제에 집중할 수 있게 하는 것입니다.

**프로 팁:** 투명성을 위해 GitHub Actions 로그에서 Action 출력도 확인해 보세요. Gemini CLI Action 로그에는 어떤 프롬프트를 실행했고 어떤 변경을 만들었거나 제안했는지가 표시됩니다. 이는 신뢰를 쌓는 데도 도움이 되고 동작을 다듬는 데도 유용합니다. 또한 팀은 엔터프라이즈급 안전장치도 마련해 두었습니다. 예를 들어 워크플로우에서 AI가 실행하려는 모든 셸 명령이 [여러분이 허용 목록(allow-list)에 올린 것](https://blog.google/technology/developers/introducing-gemini-cli-github-actions/#:~:text=in%20your%20environment%2C%20drastically%20reducing,your%20preferred%20observability%20platform%2C%20like)인지 요구할 수 있습니다. 그러니 중요한 프로젝트에서도 주저하지 말고 사용해 보세요. 그리고 Gemini CLI로 멋진 커스텀 워크플로우를 만들었다면 커뮤니티에 기여하는 것도 고려해 보세요. 이 프로젝트는 리포지토리에서 새로운 아이디어를 환영합니다!

## 팁 26: 통찰력 및 관찰 가능성을 위해 텔레메트리 활성화하기

**빠른 사용 사례:** 내장된 **OpenTelemetry** 계측 기능을 켜서 Gemini CLI가 어떻게 사용되고 성능은 어떤지 더 깊은 통찰을 얻으세요. AI 세션의 메트릭, 로그 및 트레이스를 모니터링하여 사용 패턴을 분석하거나 문제를 해결할 수 있습니다.

측정하고 최적화하기를 좋아하는 개발자를 위해 Gemini CLI는 내부에서 일어나는 일을 노출하는 관찰 가능성 기능을 제공합니다. **OpenTelemetry (OTEL)**를 활용하여 세션에 대한 구조화된 텔레메트리 데이터를 내보낼 수 있습니다. 여기에는 사용된 토큰 수, 응답 지연 시간과 같은 메트릭, 수행된 작업의 로그, 도구 호출 트레이스 등이 포함됩니다. 이를 통해 다음과 같은 질문에 답할 수 있습니다: *내가 가장 자주 사용하는 커스텀 명령어는 무엇인가? 이번 주에 AI가 이 프로젝트의 파일을 몇 번 편집했는가? 테스트 실행 요청 시 평균 응답 시간은 얼마인가?* 이러한 데이터는 사용 패턴과 성능을 이해하는 데 매우 유용합니다. 팀에서는 개발자가 AI와 어떻게 상호작용하는지, 병목 지점은 어디인지 파악할 수 있습니다.

기본적으로 텔레메트리는 **꺼져 있습니다**(개인정보 보호 및 성능 존중). `settings.json`에서 `"telemetry.enabled": true`로 설정하거나 `--telemetry` 플래그로 시작하여 활성화할 수 있습니다. 또한 데이터 전송 **대상**을 선택할 수 있습니다. 로컬에 기록하거나 Google Cloud와 같은 백엔드로 보낼 수 있습니다. 빠르게 시작하려면 `"telemetry.target": "local"`로 설정하세요. 그러면 로컬 파일에 JSON 로그를 기록하며 이를 파싱하거나 다른 도구에 입력할 수 있습니다. 더 강력한 모니터링을 위해서는 대상을 `gcp`(Google Cloud)로 설정하거나 Jaeger, Datadog 등 OpenTelemetry 호환 시스템과 통합할 수 있습니다. 사실 Gemini CLI의 OTEL 지원은 벤더 중립적이어서 Prometheus 등 거의 모든 관찰 가능성 스택으로 데이터를 내보낼 수 있습니다. Google Cloud를 사용하는 경우 데이터가 직접 Cloud Logging 및 Cloud Monitoring으로 전송되어 대시보드와 알림 도구를 바로 사용할 수 있습니다.

어떤 통찰을 얻을 수 있을까요? 텔레메트리는 도구 실행, 오류 및 주요 마일스톤과 같은 이벤트를 캡처합니다. 또한 프롬프트 처리 시간과 토큰 수와 같은 메트릭도 기록합니다. 팀 전체에서 각 슬래시 명령어가 몇 번 사용되었는지 집계하거나 코드 생성이 얼마나 자주 호출되는지 분석할 수도 있습니다. 지연 시간을 추적하여 API 속도 제한이나 모델 변경의 영향을 모니터링할 수도 있습니다. 오류나 예외 상황도 컨텍스트와 함께 기록되어 디버깅에 큰 도움이 됩니다. 이 모든 데이터는 시각화가 가능하며, 예를 들어 "일일 사용 토큰 수"나 "도구 X의 오류율" 대시보드를 만들 수 있습니다. 이는 특히 엔터프라이즈 환경에서 모든 것이 원활하게 실행되도록 보장하는 데 유용합니다.

텔레메트리를 켜면 약간의 오버헤드가 발생하므로 개인적인 용도로 100% 켜둘 필요는 없습니다. 하지만 디버깅이나 간헐적인 상태 확인에는 환상적입니다. CI 서버나 팀 공유 환경에서 활성화하여 통계를 수집하고, 로컬에서는 필요할 때만 켜는 방식을 고려해 보세요. 모든 텔레메트리는 사용자의 제어하에 있으며 지정한 곳으로만 데이터가 전송됩니다. 이 기능은 Gemini CLI를 블랙박스에서 관측소로 변환하여 AI 에이전트가 세상과 상호작용하는 방식을 밝히고 지속적으로 개선할 수 있게 해줍니다.

**프로 팁:** 현재 세션의 빠른 통계만 보고 싶다면 `/stats` 명령어를 사용하세요. 토큰 사용량 및 세션 길이와 같은 메트릭을 CLI에서 즉시 보여줍니다. 하지만 장기적이고 다중 세션 분석을 위해서는 텔레메트리가 정답입니다. 클라우드로 데이터를 보내는 경우 알림(오류 급증이나 토큰 사용량 임계값 도달 시)을 설정하여 팀 내 사용 현황을 선제적으로 관리할 수 있습니다.

## 팁 27: 로드맵 주시하기 (백그라운드 에이전트 등)

**빠른 사용 사례:** 다가올 Gemini CLI 기능에 대해 정보를 얻으세요. 공개된 **Gemini CLI 로드맵**을 팔로우하면 *장기 실행 작업을 위한 백그라운드 에이전트*와 같은 주요 계획된 개선 사항을 미리 알 수 있어 대비하고 피드백을 줄 수 있습니다.

Gemini CLI는 빠르게 진화하고 있으며 자주 새로운 릴리스가 나오므로 향후 계획을 추적하는 것이 현명합니다. Google은 GitHub에 Gemini CLI의 **공개 로드맵**을 유지하며 가까운 미래의 주요 집중 분야와 기능을 자세히 설명합니다. 이는 개발자들이 무엇을 작업 중이고 무엇이 준비 중인지 볼 수 있는 살아있는 문서이자 이슈 세트입니다. 예를 들어 로드맵의 흥미로운 항목 중 하나는 **백그라운드 에이전트** 지원입니다. 이는 대화형 세션을 점유하지 않고도 자율 에이전트가 백그라운드에서 작업을 계속하거나 비동기적으로 처리할 수 있게 해주는 기능입니다. 이를 통해 사용자는 장기 실행 프로세스를 Gemini CLI에 맡길 수 있습니다. 예를 들어 특정 이벤트를 모니터링하거나 주기적으로 작업을 실행하는 백그라운드 에이전트를 로컬이나 클라우드에서 가동할 수 있습니다. 이 기능은 장기 실행되는 자율적인 작업과 선제적인 지원을 목표로 하며, Gemini CLI의 유용성을 단순한 온디맨드 질의 이상으로 확장합니다.

로드맵을 주시함으로써 다른 계획된 기능들도 알 수 있습니다. 새로운 도구 통합, 추가적인 Gemini 모델 버전 지원, UI/UX 개선 등이 포함될 수 있습니다. 로드맵은 대개 "Extensibility", "Model", "Background" 등의 영역으로 나뉘며 목표 배포 시기가 태그되어 있습니다. 확정된 보장은 아니지만 팀의 우선순위를 파악할 수 있게 해줍니다. 오픈 소스 프로젝트이므로 각 항목에 연결된 GitHub 이슈에서 설계 제안과 진행 상황을 확인할 수도 있습니다. 변화를 미리 예상하여 필요한 기능을 준비하거나 변경 사항에 대비할 수 있습니다.

로드맵을 팔로우하는 것은 GitHub 프로젝트 보드나 "Roadmap" 레이블이 붙은 이슈를 북마크하고 주기적으로 확인하는 것만큼이나 간단합니다. 확장 기능 도입이나 IDE 통합과 같은 주요 업데이트들은 공식 발표 전에 로드맵에 암시되는 경우가 많으므로 미리 엿볼 수 있습니다. 또한 팀은 미래 기능에 대한 커뮤니티의 피드백을 환영합니다. 백그라운드 에이전트와 같은 기능에 대한 아이디어가 있다면 이슈나 토론 스레드에 의견을 남겨 개발에 영향을 줄 수 있습니다.

**프로 팁:** Gemini CLI는 오픈 소스(Apache 2.0 라이선스)이므로 로드맵을 지켜보는 것 이상의 참여가 가능합니다! 유지 관리자들은 기여를 환영하며, 특히 로드맵에 부합하는 항목들에 대한 기여를 반가워합니다. 정말 중요하게 생각하는 기능이 있다면 코드를 기여하거나 미리보기 단계에서 테스트해 보세요. 최소한 필요한 기능이 로드맵에 없다면 기능 요청을 남길 수도 있습니다. 로드맵 페이지는 변경을 제안하는 방법도 안내합니다. 프로젝트에 참여하는 것은 정보를 얻을 뿐만 아니라 사용하는 도구를 직접 만들어가는 과정이기도 합니다. 결국 Gemini CLI는 커뮤니티 참여를 염두에 두고 구축되었으며 많은 기능들이 커뮤니티의 제안에서 시작되었습니다.

## 팁 28: `Extensions`로 Gemini CLI 확장하기

**빠른 사용 사례:** 플러그 앤 플레이 방식의 **확장 프로그램(Extensions)**을 설치하여 Gemini CLI에 새로운 능력을 추가하세요. 예를 들어 좋아하는 데이터베이스나 클라우드 서비스와 통합하여 큰 수고 없이 AI의 도구 상자를 확장할 수 있습니다. CLI를 위한 앱을 설치하여 새로운 기술을 가르치는 것과 같습니다.

확장 프로그램은 2025년 말에 도입된 획기적인 기능입니다. 이를 통해 Gemini CLI의 기능을 모듈식으로 **사용자 정의하고 확장**할 수 있습니다. 확장 프로그램은 기본적으로 Gemini CLI를 외부 도구나 서비스에 연결하는 설정(및 선택적으로 코드)의 묶음입니다. 예를 들어 Google은 Cloud Run에 앱을 배포하거나 BigQuery를 관리하고 보안을 분석하는 데 도움을 주는 Google Cloud용 확장 프로그램 세트를 출시했습니다. 파트너와 커뮤니티 개발자들은 Dynatrace, Elastic, Figma, Shopify, Snyk, Stripe 등을 위한 다양한 확장 프로그램을 구축해 왔으며 그 목록은 계속 늘어나고 있습니다. 적절한 확장 프로그램을 설치하면 즉시 해당 분야의 특화된 도구들을 사용할 수 있게 됩니다. 이 기능의 묘미는 확장 프로그램이 AI에게 새로운 도구를 효과적으로 사용하는 방법을 가르치는 **"플레이북(Playbook)"**과 함께 제공된다는 점입니다. 즉, 설치 후 해당 서비스와 관련된 작업을 요청하면 AI는 마치 해당 지식이 원래 있었던 것처럼 적절한 API나 명령을 호출하는 방법을 알게 됩니다.

사용 방법은 매우 간단합니다. CLI에 `gemini extensions install <URL>` 명령어가 있습니다. 일반적으로 확장 프로그램의 GitHub 리포지토리 URL이나 로컬 경로를 제공하면 CLI가 이를 가져와 설치합니다. 예를 들어 공식 확장 프로그램을 설치하려면 다음과 같이 실행합니다: `gemini extensions install https://github.com/google-gemini/gemini-cli-extension-cloud-run`. 몇 초 안에 환경에 추가되며(보통 `~/.gemini/extensions/` 폴더에 저장됨), `/extensions` 명령어로 활성 상태를 확인할 수 있습니다. 이제 AI는 새로운 도구를 마음껏 사용할 수 있습니다. Cloud Run 확장 프로그램이라면 "내 앱을 Cloud Run에 배포해 줘"라고 말하면 실제 `gcloud` 명령을 호출하여 실행할 수 있습니다. 확장 프로그램은 선택적으로 설치할 수 있는 일류 기능 확장이며, CLI를 가볍게 유지하면서도 무엇이든 통합할 수 있는 옵션을 제공합니다.

확장 프로그램을 둘러싼 **개방형 생태계**가 존재합니다. Google은 사용 가능한 목록을 보여주는 공식 페이지를 운영하며, 프레임워크가 열려 있어 누구나 직접 만들어 공유할 수 있습니다. 사내 API나 특정 워크플로우가 있다면 확장 프로그램을 만들어 Gemini CLI의 지원을 받을 수 있습니다. 만드는 법도 생각보다 쉽습니다. `gemini-extension.json` 파일을 포함한 디렉토리를 만들고 새로운 도구가 포함된 확장을 정의하면 됩니다. 새로운 슬래시 명령어를 만들거나 AI가 호출할 원격 API를 지정할 수도 있습니다. CLI는 이를 실행 시 로드하도록 설계되었습니다. 많은 확장 프로그램들이 AI가 사용할 커스텀 *MCP 도구*를 추가하는 방식으로 구성됩니다. 예를 들어 외부 번역 API를 연결하여 `/translate` 명령어를 추가하는 확장 프로그램을 만들 수 있습니다.

확장 프로그램을 관리하려면 `install` 외에도 `update`나 `remove` 명령어를 사용하면 됩니다. 사용 중인 확장 프로그램에 개선 사항이 있는지 주기적으로 확인하는 것이 좋습니다. 향후 "확장 프로그램 마켓플레이스" 형태의 인터페이스가 도입될 수 있지만, 지금은 GitHub 리포지토리와 공식 카탈로그를 탐색하는 것이 새로운 것을 발견하는 방법입니다. 출시 당시 Genkit(생성형 AI 앱 빌드용), 다양한 Google Cloud 확장 프로그램 등이 큰 인기를 끌었습니다.

**프로 팁:** 직접 확장 프로그램을 만들고 싶다면 기존의 예시들을 먼저 살펴보세요. 공식 문서는 스키마와 기능을 설명하는 **확장 프로그램 가이드**를 제공합니다. 비공개 확장을 만드는 간단한 방법은 `GEMINI.md`에서 `@include`를 사용하여 스크립트나 컨텍스트를 주입하는 것이지만, 정식 확장 프로그램은 도구를 패키징하는 등 더 큰 힘을 실어줍니다. 또한 확장 프로그램은 컨텍스트 파일을 포함할 수 있으므로 도메인 지식을 미리 로드하는 데 사용할 수 있습니다. 회사 API에 대한 요약과 호출 도구가 포함된 확장 프로그램을 상상해 보세요. AI는 해당 API와 관련된 요청을 완벽하게 처리할 수 있게 됩니다. 확장 프로그램은 Gemini CLI가 세상의 모든 것과 인터페이스할 수 있는 새로운 세상을 열어줍니다. 마켓플레이스를 주시하고 유용한 것을 만들었다면 커뮤니티에 공유해 보세요!

## 추가 재미: 코기 모드 이스터 에그 🐕

마지막으로 생산성 팁은 아니지만 즐거운 이스터 에그를 소개합니다. Gemini CLI에서 `/corgi` 명령을 입력해 보세요. **"코기 모드(corgi mode)"**가 켜지며 귀여운 코기 애니메이션이 터미널을 가로질러 달려갑니다! 코딩에 직접적인 도움은 안 되지만, 긴 코딩 세션 중에 분위기를 환전해 줄 수 있습니다. CLI 인터페이스에서 달려가는 ASCII 아트 코기를 볼 수 있습니다. 끄려면 다시 `/corgi`를 실행하면 됩니다.

이는 팀이 재미로 추가한 기능입니다. 제작자들이 도구 곳곳에 장난기를 숨겨두었음을 보여줍니다. 잠깐의 휴식이나 미소가 필요할 때 `/corgi`를 시도해 보세요. 🐕🎉

*(소문에 따르면 "/partyparrot" 같은 다른 이스터 에그나 모드도 있을지 모른다고 하네요. 치트 시트나 도움말에 적혀 있으니 비밀은 아니지만 잘 사용되지는 않습니다. 이제 여러분도 이 비밀을 알게 되었습니다!)*

---

**결론:**

지금까지 Gemini CLI를 위한 종합적인 프로 팁과 기능들을 살펴보았습니다. `GEMINI.md`를 통한 지속적인 컨텍스트 설정부터 커스텀 명령어 작성, MCP 서버와 같은 고급 도구 활용, 멀티모달 입력 및 워크플로우 자동화까지 이 AI 명령줄 어시스턴트가 할 수 있는 일은 정말 많습니다. 개발자로서 여러분은 Gemini CLI를 일상 업무에 통합하여 지루한 작업을 처리하고, 통찰력을 얻고, 심지어 환경 문제를 해결하는 강력한 동맹군으로 활용할 수 있습니다.

오픈 소스 프로젝트로서 커뮤니티의 기여와 함께 Gemini CLI는 매우 빠르게 진화하고 있으므로 새로운 기능과 개선 사항이 계속해서 등장할 것입니다. 이 가이드의 프로 팁들을 익힘으로써 여러분은 이 도구의 잠재력을 최대한 활용할 준비를 마쳤습니다. 이는 단순히 AI 모델을 사용하는 것을 넘어, 소프트웨어를 개발하고 관리하는 방식 깊숙이 AI를 통합하는 과정입니다.

Gemini CLI와 함께 즐겁게 코딩하시고, "터미널 속의 AI 에이전트"가 여러분을 얼마나 멀리 데려다줄지 마음껏 탐험해 보세요.

**이제 여러분의 손끝에는 AI라는 스위스 아미 나이프가 쥐어져 있습니다. 현명하게 사용한다면 더욱 생산적이고 (어쩌면 더 행복한) 개발자가 될 수 있을 것입니다!**
