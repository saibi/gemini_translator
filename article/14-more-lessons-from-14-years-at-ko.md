# 출처 및 번역 정보
- **원문 URL:** https://addyo.substack.com/p/14-more-lessons-from-14-years-at
- **번역:** Cursor AI (기술 문서 번역)

---

# 구글에서 14년 동안 배운 교훈 14가지 추가편

### 이번에는 팀, 신뢰, 그리고 코드 주변의 시스템에 대해.

[Addy Osmani](https://substack.com/@addyosmani)  
Feb 12, 2026

얼마 전 저는 [구글에서 보낸 시간의 21가지 교훈](https://addyo.substack.com/p/21-lessons-from-14-years-at-google)을 적어 두었습니다. 어떤 부분이 사람들 마음에 남았는지에 대한 반응은 제게도 의외였습니다. 기술 자체에 대한 조언이 아니라, 사람과 의사결정, 그리고 함께 무언가를 만든다는 “지저분한 현실”에 대한 이야기들이었습니다.

그 덕분에, 제가 첫 글에서 중요한 것을 꽤 많이 남겨 두었다는 걸 깨달았습니다. 첫 목록은 개인의 역량(개발자로서 더 나은 코드를 쓰는 법, 커리어를 어떻게 생각할지)에 좀 더 치우쳐 있었습니다. 하지만 제가 배운 가장 어려운 교훈들 중 일부는 “내가 어떻게 일하는가”가 아닙니다. “팀이 어떻게 일하는가”에 관한 것입니다. 의사결정이 실제로는 어떻게 내려지는지, 조율이 어디서 무너지는지, 출시(Ship)하는 그룹과 빙빙 도는 그룹을 가르는 것이 무엇인지 같은 것들입니다.

이 교훈들은 첫 글에서 멈춘 지점부터 이어집니다. “더 나은 개인 엔지니어”가 되는 이야기라기보다는, **엔지니어링을 둘러싼 시스템**에 관한 이야기입니다.

## 1. 최고의 엔지니어는 “해결할 문제”를 제대로 고른다

모든 “예(Yes)”는 다른 무엇인가에 대한 암묵적인 “아니오(No)”입니다.

저는 재능 있는 엔지니어들이 번아웃에 빠지는 모습을 여러 번 봤습니다. 모든 것에 “예”라고 했기 때문입니다. 모든 버그, 모든 기능 요청, 모든 “잠깐만 도와줘”까지 말입니다. 그러다 보면 캘린더는 남의 우선순위로 꽉 차고, 본인의 로드맵은 반쯤 끝난 아이디어들의 묘지가 됩니다.

때로는 그저 제품을 정말 아끼기 때문이기도 합니다. 하지만 “있으면 좋음(nice to have)”으로부터 내 대역폭(bandwidth)을 지키는 일은, 프로덕션을 장애로부터 지키는 것과 비슷하게 다뤄야 합니다. 중요한 건 **올바른 일을 하고**, **틀린 일은 미완성으로 남겨 두는 것**입니다.

불균형하게 큰 임팩트를 만드는 엔지니어가 꼭 더 빠르거나 더 똑똑한 것은 아닙니다. 무엇이 자신의 주의를 받을 자격이 있는지에 훨씬 더 냉정합니다. “잘못된 일에 시간을 쓰는 기회비용”은 결국 “잘못된 일에 시간을 쓰는 것”임을 배운 사람들입니다.

## 2. 어떤 결정을 요청하는지 말할 수 없다면, 그 미팅을 할 준비가 아니다

대부분의 미팅이 실패하는 이유는, 미팅이 불필요해서가 아니라 **기록(저널링)을 미팅으로 위장**했기 때문입니다. 똑똑한 사람들이 문제 주변을 빙빙 돌면서도, 정작 자신들이 무엇을 필요로 하는지 이름 붙이지 못하는 시간을 저는 수백 시간이나 봤습니다. 그리고 미팅은 “분위기(vibes)”만 남긴 채 끝나고, 오너는 없습니다.

저는 “요청(ask)”부터 시작하는 법을 배웠습니다. 결정을 요청하는 건 다음 중 하나여야 합니다.

- 승인(approve)
- 선택(choose)
- 막힌 것 해소(unblock)
- 공유(inform)

이 네 단어만으로 저는 모든 미팅 준비 방식이 바뀌었습니다. 이 중 하나를 고를 수 없다면, 누구의 시간을 쓰게 만들 준비가 안 된 겁니다. 반대로 제가 미팅을 “받는” 입장일 때는, 처음 2분 안에 “제가 어떤 결정을 내려드리면 되나요?”라고 묻기 시작했습니다. 다소 직설적으로 들리지만, 대부분은 오히려 안도합니다. 본인도 “결정을 정의하지 못했다”는 걸 몰랐던 경우가 많거든요.

모호한 미팅의 숨은 비용은, 그 1시간만이 아닙니다. 그 뒤에 따라오는 **표류(drift) 일주일**입니다. 모두가 결코 오지 않는 명확함을 기다리게 됩니다.

## 3. “우리 ~해야 한다”는 계획이 아니다. “화요일에 내가 ~하겠다”가 계획이다

움직임(motion)과 진전(progress)의 차이는 **구체성**입니다.

팀은 의도(intention)에 빠져 익사합니다. “온보딩 흐름을 개선해야 한다”, “레이턴시를 줄여야 한다”, “API 문서화를 해야 한다” 같은 문구가 로드맵을 채우는 걸 수도 없이 봤습니다. 몇 달이 지나도 똑같은 항목이 그대로 남아, 먼지와 죄책감만 쌓입니다. [에이전틱 엔지니어링(agentic engineering)](https://addyosmani.com/blog/agentic-engineering/)이 있으니 이제 해결된 문제라고 생각할 수도 있지만, 아직은 아닙니다.

대화를 “누군가 실제로 할 수 있는 최소 다음 행동”으로 바꾸고, 거기에 이름과 날짜를 붙이세요. “온보딩을 개선하자”가 아니라 “화요일에 Sarah가 사용자 세션 3개를 진행하고, 주요 마찰 지점을 문서화한다”처럼요.

이건 “사람이 진전을 만들려면 접지력(traction)이 필요하다”는 사실을 존중하는 이야기입니다. 모호한 의도는 불안을 만들고, 구체적인 약속은 추진력을 만듭니다. 계획이 완벽할 필요는 없습니다. 누군가 진짜로 시작할 수 있을 만큼만 구체적이면 됩니다.

## 4. 느린 코드는 때로 증상이다. 느린 결정은 항상 문제다

속도는 똑똑한 사람들이 머뭇거리게 만드는 마찰을 제거하는 데서 나옵니다. 가능할 때는 *bias towards action*(행동 편향)을 가지세요.

프로젝트가 질질 끌리면, 본능적으로 속도(velocity)를 탓하고 싶어집니다. 사람들이 충분히 열심히 안 해서, 코드베이스가 엉망이라서, 엔지니어가 부족해서… 같은 이야기요. 하지만 제 경험상 느린 코드는 종종 **증상**입니다. 느린 결정이 **질병**입니다.

결정이 매번 몇 주, 몇 달씩 걸린다면 더 깊게 들여다보세요.

- 컨텍스트가 부족하면 트레이드오프(tradeoff)를 평가할 수 없습니다.
- 오너십이 불명확하면 모두가 “누군가가 결정하겠지”를 기다립니다.
- 책임에 대한 두려움이 크면 사람들은 결단 대신 회피(hedge)를 선택합니다.

제가 함께 일했던 가장 빠른 엔지니어링 팀은, 최고의 프로그래머가 모인 팀이 아니었습니다. **권한이 명확하고, 컨텍스트가 공유되며, 틀려도 커리어 리스크가 되지 않는 환경** 덕분에 결정이 몇 주가 아니라 몇 시간 안에 일어나는 팀이었습니다.

## 5. 신뢰성(reliability)은 제품 기능이다. 기능처럼 다뤄라

사용자는 신뢰성을 칭찬하진 않지만, 신뢰성이 없으면 바로 알아챕니다.

이건 위험한 역학을 만듭니다. 신뢰성 작업은 실패하기 전까지는 보이지 않습니다. 그래서 반짝이는 신기능에 비해 늘 리소스가 부족해집니다.

에러 버짓(error budget)은 이 트레이드오프를 명시적으로 만드는 한 가지 방법입니다. 서비스의 SLO가 99.9% 업타임(uptime)이라면, 혁신(innovation)에 “쓸 수 있는” 다운타임 예산이 0.1%라는 뜻입니다. 그 예산을 다 써버리면, 다시 벌어들일 때까지 신뢰성에 집중합니다. 이는 리스크에 대해 솔직한 대화를 나누기 위한 프레임워크입니다.

속도와 신뢰성을 둘 다 유지하는 팀은, 영웅적 대응(heroics)으로 그렇게 하지 않습니다. 신뢰성을 **일급(first-class) 제품 기능**으로 취급합니다. 로드맵이 있고, 메트릭이 있고, 이를 대변하는 사람이 있습니다.

제품 리뷰 없이 기능을 출시하지 않듯이, 어떤 형태로든 신뢰성 논의 없이 시스템을 출시하지 마세요.

## 6. 팀 간의 나쁜 인터페이스를 “커뮤니케이션”으로 덮을 수는 없다

팀 상호작용 모드(interaction mode)는 이유가 있어서 존재합니다. 예를 들면 협업(collaboration: 밀접하게 함께 일하기), 서비스(service: 명확한 API와 SLA), 또는 촉진(facilitation: 한 팀이 다른 팀의 역량을 키우도록 돕기) 같은 것들입니다.

대부분의 크로스팀 고통은 노력 부족이나 선의의 문제가 아닙니다. **경계(boundary)가 불명확하고 계약(contract)이 엉망**인 문제입니다. “커뮤니케이션을 개선하자”며 미팅을 더 넣고, Slack 채널을 더 만들고, 동기화(sync)를 더 만들어도 좋아지지 않는 경우를 저는 많이 봤습니다.

문제는 사람들이 말을 안 해서가 아닙니다. **팀 간 인터페이스가 정의되지 않았기 때문**입니다.

- 누가 무엇을 소유(ownership)하는가?
- 계약은 무엇인가?
- A팀은 B팀에게 무엇을 기대할 수 있고, B팀은 A팀에게 무엇을 기대할 수 있는가?

의도적으로 선택하면, 일을 굴리기 위해 필요한 미팅이 훨씬 줄어듭니다. 나쁜 인터페이스를 커뮤니케이션으로 종이로 덮으려 하면, 가장 협업적인 사람들을 번아웃시키는 동안에도 근본적인 기능 장애(dysfunction)는 남아 있게 됩니다.

## 7. 최고의 에스컬레이션(escalation)은 제안(proposal)과 함께 온다

“문제가 이거예요”는 일의 반쪽입니다. 저는 예전엔 제 역할이 문제를 찾아내 리더십에게 가져가는 것이라고 생각했습니다. 필요하긴 하지만, 충분하지 않습니다.

“여기 선택지 두 가지가 있고, 각각의 트레이드오프가 이렇고, 저는 이걸 추천합니다”가 막힌 것을 풀고 신뢰를 얻는 방식입니다. 생각을 해 왔다는 걸 보여 줍니다. 의사결정자에게 “열린 문제”가 아니라, **아주 구체적으로 반응할 수 있는 대상**을 줍니다.

그들의 일을 쉽게 만들면, 그들은 당신이 필요한 것을 더 기꺼이 제공하게 됩니다.

“도와주세요”와 “A와 B 중에서 골라 주세요. 그리고 제가 B 쪽으로 기우는 이유는 이렇습니다”의 차이는, 문제 제기자(problem-raiser)와 문제 해결자(problem-solver)의 차이입니다.

둘 다 문제를 식별합니다. 하지만 신뢰와 자율성(autonomy)이 늘어나는 쪽은 하나뿐입니다.

## 8. 영웅 문화를 피하라. 영웅이 필요 없는 시스템을 만들어라

영웅은 번아웃되어 있고, 문서화가 안 되어 있으며, 단일 장애점(single point of failure)입니다.

한 사람이 매번 하루를 구하는 패턴이 반복된다면, 그건 훈장이 아니라 **실패 모드**입니다. 저는 팀이 영웅을 축하하는 동안, 영웅주의가 필요해진 기능 장애는 외면하는 모습을 봤습니다.

그 사람이 떠나면(그리고 결국엔 떠납니다), 팀은 아무도 시스템이 실제로 어떻게 동작하는지 모른다는 사실을 깨닫게 됩니다. 영웅을 축하하는 문화는 시스템적인 문제를 가립니다. “평범한 사람이 평범한 하루에” 성공적으로 따라갈 수 있는 경로가 작동하지 않는다는 뜻이니까요.

정상 경로(normal path)를 기본값으로 만드세요. 시스템을 문서화하세요. 지식을 퍼뜨리세요. 예외적인 위기 상황이 아니라 “평균적인 화요일”을 기준으로 설계하세요. 영웅은 불필요해야 하고, 필요하다면 **불필요하게 만들기 위해 일하고 있어야** 합니다.

## 9. 관측 가능성(observability)을 기능의 일부로 만들어라

텔레메트리(telemetry) 없는 기능은, 변장한 책임(liability)입니다.

프로덕션에서 어떻게 동작하는지 모르는 상태로 기능을 출시했다면, 당신은 불확실성을 출시한 겁니다.

저는 팀이 런칭을 축하한 뒤, 몇 주 후에 그 기능이 사용자 20%에게 조용히 실패하고 있었다는 걸 알게 되는 걸 봤습니다. 로그도, 메트릭도, 대시보드도 없고, “이해가 있어야 할 자리”에 공백만 남아 있었습니다. 그리고 나중에 이를 고치려면, 관측 가능성을 갖춘 상태로 제대로 A/B 테스트를 하기 위해 기능을 되돌리는(unship) 고통까지 생길 수 있습니다.

로그, 트레이스(traces), 대시보드, 알림(alert)은 “옵스 작업(ops work)”이 아닙니다. 학습하는 방법입니다. 진짜 사람들이 진짜 조건에서 진짜로 사용하는 상황에서, 내가 만든 것이 실제로 동작하는지 아는 방법입니다.

제가 아는 최고의 엔지니어들은 관측 가능성을 “정의된 완료(definition of done)”의 일부로 취급합니다. “코드를 썼다”가 아니라 “코드를 썼고, **그게 동작하는 걸 볼 수 있다**”입니다.

## 10. 작은 PR은 친절이다. 특히 PR이 AI 생성이라면 더더욱

작은 변경은 리뷰하기 쉽고, 추론하기 쉽고, 되돌리기 쉽습니다.

저는 예전엔 큰 Pull Request(PR)를 올리곤 했습니다. 완성된 기능을 한 번에 리뷰받는 게 좋다고 생각했습니다. 하지만 그건 리뷰어의 정신 건강을 희생시키며 제 편의를 최적화한 행동이었습니다. 작은 PR이 대개 모두에게 더 좋습니다.

작은 PR은 더 빨리 배포됩니다. 누군가가 당신의 천 줄짜리 diff를 이해할 시간을 내기 전까지 리뷰 큐에서 잠들어 있지 않기 때문입니다. 팀원이 당신의 속도를 신뢰하길 원한다면, **리뷰 가능한 형태로** 일을 만드세요.

숨은 이점도 있습니다. 작은 PR은 당신이 “증분(increment)”으로 생각하게 만듭니다. 하나의 거대한 변경이 아니라, 능력을 조각조각 쌓아 올립니다. 각 조각은 피드백을 받고, 각 조각은 독립적으로 롤백할 수 있습니다. PR 하나하나로 보면 느려 보일 수 있지만, 실제 프로덕션까지는 더 빠릅니다.

## 11. 팀을 추가하면 노드(node)만 늘어나는 게 아니라 엣지(edge)가 늘어난다

조율 비용(coordination cost)은 인원수보다 더 빠르게 증가합니다.

그래서 “사람을 더 투입하면 되지”가 자주 실패하고, 프로젝트 후반에 인원을 추가하면 오히려 더 늦어지는 이유가 됩니다. 새로운 사람은 조율해야 할 모든 사람과의 커뮤니케이션 오버헤드를 추가합니다. 그래프는 커지는 것뿐 아니라 **더 촘촘해집니다**.

저는 팀 규모를 두 배로 늘렸는데도 산출물이 거의 변하지 않아 진심으로 당황하는 매니저를 봤습니다. 답은 늘 같습니다. 새로운 엣지들이 새로운 용량(capacity)을 먹어버린 겁니다. 사람이 늘면 얼라인먼트 미팅, 컨텍스트 공유, 이제는 이해관계자가 더 늘어난 의사결정을 기다리는 시간이 늘어납니다.

해결책은 채용을 멈추는 게 아닙니다. 엣지를 줄이도록 의도적으로 설계하는 겁니다. 명확한 오너십, 최소 의존성으로 자율적으로 움직이는 팀, 발맞춰(lockstep) 걷는 대신 병렬로 일할 수 있게 해주는 인터페이스. 최고의 조직은 사람이 가장 많은 조직이 아니라, **사람 한 명당 레버리지(leverage)가 가장 큰 조직**입니다.

## 12. 마이그레이션은 결코 “마이그레이션만”이 아니다

모든 마이그레이션은 “현재 시스템”, “원하는 시스템”, 그리고 어느 쪽도 원하지 않았던 사람들 사이의 협상(negotiation)입니다.

저는 한 분기라고 추정했던 마이그레이션이 수년으로 늘어나는 걸 봤습니다. 기술적 작업이 틀려서가 아니라, 아무도 “사람 작업(human work)”을 계산하지 않았기 때문입니다. 각 팀이 자신의 로드맵보다 당신의 마이그레이션을 우선순위에 두도록 설득하는 일, 아무도 몰랐던 엣지 케이스의 긴 꼬리(long tail)를 지원하는 일, 그리고 구형 시스템이 죽기를 거부하는 동안 새/구 시스템을 병행 운영하는 일 같은 것들입니다.

기술 계획은 쉬운 부분입니다. 어려운 부분은 **공존(coexistence)을 설계**하는 것입니다. 생각보다 훨씬 오래, 구형과 신형을 동시에 운영하게 될 겁니다. “레거시(legacy)” 시스템이 문서화되지 않은 의사결정과, 누가 설계했는지 기억도 못하지만 모두가 의존하는 워크플로를 품고 있다는 사실을 발견하게 될 겁니다. 그리고 모든 팀이 한 번에 하던 일을 멈추지 않아도 되도록, 채택(adoption) 전략이 필요합니다.

실제로 끝나는 마이그레이션은 세 가지 공통점이 있습니다.

- 킥오프 이후에도 계속 관여하는 스폰서(sponsor)
- 부업(side quest)처럼 취급하지 않고 정말로 소유하는 팀
- 사람들이 “진짜라고 믿는” 명확한 폐기(deprecation) 날짜

세 가지가 모두 없으면, 마이그레이션은 영원히 “거의 끝”인 상태가 됩니다. 시작하지 않는 것보다 나쁩니다. 이제 두 시스템을 무기한으로 유지하는 비용을 내고 있으니까요.

끝까지 자금을 댈 의지가 없다면, 마이그레이션을 시작하지 마세요.

## 13. AI는 초안을 싸게 만든다. 취향(taste)은 비싸진다

이제 누구나 코드를 생성할 수 있습니다. 코드, 콘텐츠, 디자인을 “만드는” 장벽은 크게 무너지고 있습니다. AI는 예전엔 한 개 만드는 데 걸리던 시간에 열 개 버전을 만들어 줍니다.

차별점은 “선택”입니다. 무엇을 만들지, 무엇을 지울지, 무엇을 단순화할지, 무엇을 출시하지 않을지, 그리고 “좋음(good)”이 무엇인지. 여러 선택지 사이를 구분하고 올바른 것을 고르는 능력인 **취향**이 희소한 자원이 됩니다.

AI로 선택지를 빠르게 탐색한 다음, 판단을 냉정하게 적용하세요. 이 환경에서 성장하는 엔지니어는 가장 많이 생성하는 사람이 아니라, **가장 좋은 것을 큐레이션(curate)하는 사람**일 겁니다.

생산(production)은 싸고, 편집(editing)은 비쌉니다. 선택(selection)이 전부입니다.

## 14. 신뢰(trust)는 팀을 위한 레이턴시 최적화다

이건 가장 레버리지가 큰 것입니다. 시스템이 아니라 **신뢰도(credibility)**입니다.

사람들이 당신을 신뢰하면, 결정을 승인받기 위해 다섯 번의 미팅이 필요하지 않습니다. 유능함, 선의, 그리고 끝까지 해낸다는 걸 기본값으로 가정합니다. 신뢰가 낮은 환경에서는 몇 주 걸리는 결정이, 신뢰가 높은 환경에서는 몇 시간 만에 일어납니다.

약속을 지키는 매번, 실수에 대해 솔직한 매번, 누군가의 일을 더 쉽게 만들어 주는 매번, 당신은 여러 해 동안 배당을 지급할 “계좌”에 입금하고 있는 겁니다.

저는 기술 역량이 아주 뛰어나지 않아도 모두가 신뢰해서 엄청난 일을 해내는 엔지니어들을 봤습니다. 반대로, 매우 뛰어난 엔지니어가 아무도 전화를 받아주지 않아 작은 일도 못 하는 경우도 봤습니다.

당신과 함께 출시(Ship)해 줄 사람이 없다면, 코드는 중요하지 않습니다.

## 맺으며

첫 글에서 저는 이 교훈들이 결국 “호기심을 유지하고, 겸손을 유지하며, 일이 결국 사람에 관한 것임을 기억하는 것”으로 귀결된다고 했습니다. 지금도 그렇게 믿습니다.

하지만 두 번째 목록에 관통하는 흐름이 있다면, 더 구체적으로는 이겁니다. **평범한 사람이 평범한 하루에 특별한 일을 할 수 있게 만드는 것**이 우리의 일이라는 점입니다. 엔지니어링 커리어는 이런 것들을 ‘힘들게’ 배울 시간도 충분히 주고, 저 역시 구글에서 일하는 동안 지금까지 정말 많이 배웠습니다.

이 중 몇 가지라도 여러분이 생길 수 있었던 흉터를 하나둘 줄여주면 좋겠습니다. 그리고 혹시 도움이 됐다면, 여정의 조금 앞에서 걷고 있는 누군가에게 여러분이 알아낸 것을 공유해 주세요.

좋은 교훈은 그렇게 전해지니까요.
